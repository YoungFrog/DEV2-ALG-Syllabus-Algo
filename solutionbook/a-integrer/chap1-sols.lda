// ex1
algorithme estNul(tab : tableau de n x m entiers, lg, col: entiers) -> booléens
	retourner tab[lg, col] = 0
fin algorithme

// ex2
algorithme assigner(tab IN OUT : tableau de n x m entiers, lg IN, col IN, val IN : entiers)
	si estNul(tab, lg, col) alors
		tab[lg,col] <- val
	fin si
fin algorithme

// ex3
algorithme estBordBas(tab : tableau de n × m entiers, lg, col : entiers) → booléen
	retourner lg = n - 1
fin algorithme
algorithme estBordGauche(tab : tableau de n × m entiers, lg, col : entiers) → booléen
	retourner col = 0
fin algorithme
algorithme estBordHaut(tab : tableau de n × m entiers, lg, col : entiers) → booléen
	retourner lg = 0
fin algorithme
algorithme estBordDroit(tab : tableau de n × m entiers, lg, col : entiers) → booléen
	retourner col = m - 1
fin algorithme

algorithme estBord(tab : tableau de n × m entiers, lg, col : entiers) → booléen
	retourner estBordBas(tab, lg, col) OU estBordGauche(tab, lg, col) OU
	          estBordDroit(tab, lg, col) OU estBordHaut(tab, lg, col)
fin algorithme

// ex4
algorithme estCoinHG(tab : tableau de n × m entiers, lg, col : entiers) → booléen
	retourner estBordGauche(tab, lg, col) ET estBordHaut(tab, lg, col)
fin algorithme
algorithme estCoinHD(tab : tableau de n × m entiers, lg, col : entiers) → booléen
	retourner estBordDroit(tab, lg, col) ET estBordHaut(tab, lg, col)
fin algorithme
algorithme estCoinBG(tab : tableau de n × m entiers, lg, col : entiers) → booléen
	retourner estBordGauche(tab, lg, col) ET estBordBas(tab, lg, col)
fin algorithme
algorithme estCoinBD(tab : tableau de n × m entiers, lg, col : entiers) → booléen
	retourner estBordDroit(tab, lg, col) ET estBordBas(tab, lg, col)
fin algorithme

algorithme estCoin(tab : tableau de n × m entiers, lg, col : entiers) → booléen
	retourner estCoinHG(tab, lg, col) OU estCoinHD(tab, lg, col) OU
	          estCoinBD(tab, lg, col) OU estCoinBG(tab, lg, col)
fin algorithme

// ex6
algorithme afficherCasesAdjacentes(tab: tableau de n entiers, lg, col : entiers)
	si NON estBordGauche(tab, lg, col) alors
		afficher lg, col-1
	fin si
	si NON estBordDroit(tab, lg, col) alors
		afficher lg, col+1
	fin si
	si NON estBordHaut(tab, lg, col) alors	
		afficher lg - 1, col
	fin si
	si NON estBordBas(tab, lg, col) alors
		afficher lg + 1, col
	fin si
fin algorithme

// ex 15
algorithme pinceauZebre(tab IN OUT : tableau de n x n entiers)
	colDepart <- 0
	pour lg de 0 à n-1 faire
		pour col de colDepart à n-1 par 3 faire
			tab[lg,col] <- NOIR
		fin pour
		si colDepart > 0 alors
			colDepart <- colDepart - 1
		sinon
			colDepart <- 2
		fin si
	fin pour
fin algorithme

algorithme pinceauSpirale(tab IN OUT : tableau de n x n entiers)
	lg <- 0
	col <- 0
	dirLg <- 0
	dirCol <- 1
	fini <- faux
	tant que NON fini faire
		tab[lg,col] <- NOIR
		si bord(lg,col,dirLg, dirCol) OU
			noircieDansDeuxCase(tab, lg,col,dirLg,dirCol) alors 
			tournerADroite(dirLg, dirCol)
		fin si
		avancer(lg, col, dirLg, dirCol)
		si caseNoireADroite(tab,lg,col,dirLg, dirCol) alors
			fini <- vrai
		fin si
	fin tant que
fin algorithme
algorithme bord(lg,col,dirLg, dirCol) -> booléen
	tmpLg <- lg
	tmpCol <- col
	avancer(tmpLg, tmpCol, dirLg, dirCol)
	retourner 0 <= tmpCol ET tmpCol < n ET 0 <= tmpLg ET tmpLg < n
fin algorithme
algorithme noircieDansDeuxCase(tab, lg,col,dirLg, dirCol) -> booléen
	tmpLg <- lg
	tmpCol <- col
	avancer(tmpLg, tmpCol, dirLg, dirCol)
	retourner tab[tmpLg, tmpCol] = NOIR
fin algorithme
algorithme tournerADroite(dirLg IN OUT : entier, dirCol IN OUT : entier)
	dirLg <- dirCol
	dirCol <- -dirLg
fin algorithme

//Tests: tournerADroite(0, 1) = (1, 0)
//		 tournerADroite(1, 0) = (0, -1)
//		 tournerADroite(0, -1)= (-1, 0)
//		 tournerADroite(-1, 0)= (0, 1)
algorithme avancer(lg IN OUT : entier, col IN OUT : entier, dirLg, dirCol : entiers)
	lg <- lg + dirLg
	col <- col + dirCol
fin algorithme
algorithme caseNoireADroite(tab,lg,col, dirLg, dirCol) -> booléen
	tmpLg <- lg
	tmpCol <- col
	tmpDirLg <- dirLg
	tmpDirCol <- dirCol
	tournerADroite(tmpDirLg, tmpDirCol)
	si NON bord(lg,col, tmpDirLg, tmpDirCol) alors
		avancer(tmpLg, tmpCol, dirLg, dirCol)
		retourner tab[tmpLg, tmpCol] = NOIR
	sinon
		retourner faux
	fin si
fin algorithme
