%DO NOT EDIT THIS FILE -- CHANGES WILL BE LOST -- see ../solbook
\chapter{Les tableaux à 2 dimensions}
\refstepcounter{Exercice}

		\begin{Solution}
			\begin{algo}
				\Algo{estNul}{\Par{tab}{\Array{n $\times$ m}{integers}}, \Par{lg, col}{integers}}{boolean}{
					\Return tab[lg][col]=0\;
				}
			\end{algo}
		\end{Solution}

\refstepcounter{Exercice}

		\begin{Solution}
			\begin{algo}
				\Algo{assigner}{\Par{tab\InOut}{\Array{n $\times$ m}{integers}}, \Par{lg\In, col\In, val\In}{integers}}{}{
					\If{estNul(tab, lg, col)}{
						tab[lg,col] \Gets val\;
					}
				}
			\end{algo}
		\end{Solution}

\refstepcounter{Exercice}

		\begin{Solution}
			\begin{algo}
				\Algo{estBordHaut}{\Par{tab}{\Array{n$\times$m}{entiers}}, \Par{lg, col}{entiers}}{booléen}{
					\Return lg = 0
				}
				\BlankLine
				\Algo{estBordBas}{\Par{tab}{\Array{n$\times$m}{entiers}}, \Par{lg, col}{entiers}}{booléen}{
					\Return lg = n - 1
				}
				\BlankLine
				\Algo{estBordGauche}{\Par{tab}{\Array{n$\times$m}{entiers}}, \Par{lg, col}{entiers}}{booléen}{
					\Return col = 0
				}
				\BlankLine
				\Algo{estBordDroit}{\Par{tab}{\Array{n$\times$m}{entiers}}, \Par{lg, col}{entiers}}{booléen}{
					\Return col = m - 1
				}
				\BlankLine
				\Algo{estBord}{\Par{tab}{\Array{n$\times$m}{entiers}}, \Par{lg, col}{entiers}}{booléen}{
					\Return estBordGauche(tab,lg,col) OU estBordDroit(tab,lg,col)\;
						\Indp OU estBordHaut(tab,lg,col) OU estBordBas(tab,lg,col)\;
				}
			\end{algo}
		\end{Solution}

\refstepcounter{Exercice}

		\begin{Solution}
			\begin{algo}
				\Algo{estCoinHG}{\Par{tab}{\Array{n$\times$m}{entiers}}, \Par{lg, col}{entiers}}{booléen}{
					\Return estBordGauche(tab, lg, col) ET estBordHaut(tab, lg, col)
				}
				\BlankLine
				\Algo{estCoinHD}{\Par{tab}{\Array{n$\times$m}{entiers}}, \Par{lg, col}{entiers}}{booléen}{
					\Return estBordDroit(tab, lg, col) ET estBordHaut(tab, lg, col)
				}
				\BlankLine
				\Algo{estCoinBG}{\Par{tab}{\Array{n$\times$m}{entiers}}, \Par{lg, col}{entiers}}{booléen}{
					\Return estBordGauche(tab, lg, col) ET estBordBas(tab, lg, col)
				}
				\BlankLine
				\Algo{estCoinBD}{\Par{tab}{\Array{n$\times$m}{entiers}}, \Par{lg, col}{entiers}}{booléen}{
					\Return estBordDroit(tab, lg, col) ET estBordBas(tab, lg, col)
				}
				\BlankLine
				\Algo{estCoin}{\Par{tab}{\Array{n$\times$m}{entiers}}, \Par{lg, col}{entiers}}{booléen}{
					\Return estCoinHG(tab,lg,col) OU estCoinHD(tab,lg,col)\;
						\Indp OU estCoinBG(tab,lg,col) OU estCoinBD(tab,lg,col)\;
				}
			\end{algo}
		\end{Solution}

\refstepcounter{Exercice}

	\begin{Solution}
		\begin{algo}
			\Algo{afficherLigneParLigne}{\Par{tab}{\Array{n $\times$ m}{T}}}{}{
				\Fori{lg}{0}{n-1}{
					\Fori{col}{0}{m-1}{
						\Write tab[lg,col]\;
					}
				}
			}
			\BlankLine
			\Algo{afficherColonneParColonne}{\Par{tab}{\Array{n $\times$ m}{T}}}{}{
				\Fori{col}{0}{m-1}{
					\Fori{lg}{0}{n-1}{
						\Write tab[lg,col]\;
					}
				}
			}
		\end{algo}
                Autre version, en ré-utilisant les algo déjà écrits :
		\begin{algo}
			\Algo{afficherLigneParLigne-v2}{\Par{tab}{\Array{n $\times$ m}{T}}}{}{
				\Fori{lg}{0}{n-1}{
                                  affichageElémentsLigne(tab, lg)\;
				}
			}
			\BlankLine
			\Algo{afficherColonneParColonne-v2}{\Par{tab}{\Array{n $\times$ m}{T}}}{}{
				\Fori{col}{0}{m-1}{
                                  affichageElémentsColonne(tab, col)
				}
			}
		\end{algo}
	\end{Solution}

\refstepcounter{Exercice}

	\begin{Solution}
          Supposons d'abord que "adjacent" implique l'existence d'un bord (par opposition à "coin") en commun avec la case en paramètres. Il y a alors maximum quatre cases adjacentes, et on peut écrire :
		\begin{algo}
			\Algo{afficherCasesAdjacentes}
				{\Par{tab}{\Array{n$\times$m}{entiers}}, \Par{lg, col}{entiers}}{}{
				\lIf{NON estBordGauche(tab, lg, col)}{
					\Write lg, col-1\;
				}
				\lIf{NON estBordDroit(tab, lg, col)}{
					\Write lg, col+1\;
				}
				\lIf{NON estBordHaut(tab, lg, col)}{
					\Write lg - 1, col\;
				}
				\lIf{NON estBordBas(tab, lg, col)}{
					\Write lg + 1, col\;
				}
			}
		\end{algo}
                La version où "adjacent" veut dire "un bord ou un coin en commun" peut être écrite de façon similaire.
	\end{Solution}

\refstepcounter{Exercice}

	\begin{Solution}
		\begin{algo}
			\Algo{proportionNuls}{\Par{tab}{\Array{n $\times$ m}{entiers}}}{réel}{
				\Decl{nbNuls}{entier}\;
				nbNuls \Gets 0\;
				\Fori{i}{0}{n-1}{
					\Fori{j}{0}{m-1}{
						\If{tab[i,j]=0}{nbNuls++}
					}
				}
				\Return $\frac{nbNuls}{n\times{}m}$\;
			}
		\end{algo}
	\end{Solution}	

\refstepcounter{Exercice}

	\begin{Solution}
		\begin{algo}
			\Algo{sommeLigne}{\Par{tab}{\Array{n $\times$ m}{entiers}},\Par{lg}{entier}}{réel}{
				\Decl{somme}{entier}\;
				somme \Gets 0\;
				\Fori{j}{0}{m-1}{
					somme \Gets somme + tab[lg,j]
				}
				\Return somme;
			}
			\BlankLine
			\Algo{moyenneLigne}{\Par{tab}{\Array{n $\times$ m}{entiers}},\Par{lg}{entier}}{réel}{
				\Return $\frac{sommeLigne(tab)}{m}$\;
			}
			\BlankLine
			\Algo{pourcentageRéussites}{\Par{notes}{\Array{n $\times$ m}{entiers}}}{réel}{
				\Decl{nbRéussites}{entier}\;
				nbRéussites \Gets 0\;
				\Fori{i}{0}{n-1}{
					\If{moyenneLigne(notes,i)>=10}{
						nbRéussites++;
					}
				}
				\Return $\frac{nbRéussites}{n}\times{}100$\;
			}
		\end{algo}
	\end{Solution}	

\refstepcounter{Exercice}

	\begin{Solution}
		\begin{algo}
			\Algo{trianglePascal}{\Par{n}{entier}}{\Array{n $\times$ n}{entiers}}{
				\Decl{pascal}{\Array{n $\times$ n}{entiers}}\;
				\Fori{i}{0}{n-1}{
					pascal[i,0] \Gets 1\;
					pascal[i,i] \Gets 1\;
					\Fori{j}{1}{i-1}{
						pascal[i,j] \Gets pascal[i-1,j-1] + pascal[i-1,j]\;
					}
				}
				\Return pascal;
			}
		\end{algo}
	\end{Solution}	

\refstepcounter{Exercice}

	\begin{Solution}
		\begin{algo}
			\Algo{tousPositifs}{\Par{tab}{\Array{n $\times$ m}{entiers}}}{booléen}{
				\Decl{tousPositifs}{booléen}\;
				\Decl{lg,col}{entiers}\;
				tousPositifs \Gets true\;
				lg \Gets 0\;
				\While{lg<n ET tousPositifs}{
					col \Gets 0\;
					\While{col<m ET tousPositifs}{
						tousPositifs \Gets tab[lg,col] > 0\;
						col++\;
					}
					lg++\;
				}
				\Return tousPositifs\;
			}
		\end{algo}
	\end{Solution}	

\refstepcounter{Exercice}

	\begin{Solution}
		\begin{algo}
			\Algo{lignePleine}{\Par{tab}{\Array{n $\times$ m}{entiers}}, \Par{lg}{integer}}{booléen}{
				\Decl{lignePleine}{booléen}\;
				\Decl{col}{entiers}\;
				lignePleine \Gets true\;
				col \Gets 0\;
				\While{col<m ET lignePleine}{
					lignePleine \Gets tab[lg,col] != 0\;
					col++\;
				}
				\Return lignePleine\;
			}
		\end{algo}
	\end{Solution}	

\refstepcounter{Exercice}

	\begin{Solution}
		\begin{algo}
			\Algo{estMagique}{\Par{carré}{\Array{n $\times$ n}{entiers}}}{booléen}{
				\Decl{sommeDiagonale}{entier}\;
				sommeDiagonale \Gets sommeDiagonale(carré)\;
				\Return sommeDiagonaleInverse(carré)=sommeDiagonale\;
				\Indp ET vérifierLignes(carré,sommeDiagonale) ET vérifierColonnes(carré,sommeDiagonale)
			}
			\BlankLine
			\Algo{sommeDiagonale}{\Par{carré}{\Array{n $\times$ n}{entiers}}}{entier}{
				\Decl{somme}{entier}\;
				somme \Gets 0\;
				\Fori{i}{0}{n-1}{
					somme \Gets somme + carré[i,i]\;
				}
				\Return somme\;
			}
			\BlankLine
			\Algo{sommeDiagonaleInverse}{\Par{carré}{\Array{n $\times$ n}{entiers}}}{entier}{
				\Decl{somme,col}{entier}\;
				somme \Gets 0\;
				col \Gets n-1\;
				\Fori{lg}{0}{n-1}{
					somme \Gets somme + carré[lg,col]\;
					col--;
				}
				\Return somme\;
			}
			\BlankLine
			\Algo{sommeLigne}{\Par{carré}{\Array{n $\times$ n}{entiers}},\Par{lg}{entier}}{entier}{
				\Decl{somme}{entier}\;
				somme \Gets 0\;
				\Fori{col}{0}{n-1}{
					somme \Gets somme + carré[lg,col]\;
				}
				\Return somme\;
			}
			\BlankLine
			\Algo{sommeColonne}{\Par{carré}{\Array{n $\times$ n}{entiers}},\Par{col}{entier}}{entier}{
				\Decl{somme}{entier}\;
				somme \Gets 0\;
				\Fori{lg}{0}{n-1}{
					somme \Gets somme + carré[lg,col]\;
				}
				\Return somme\;
			}
			\BlankLine
			\Algo{vérifierLignes}{\Par{carré}{\Array{n $\times$ n}{entiers}},\Par{sommeRéférence}{entier}}{booléen}{
				\Decl{sommeBonne}{booléen}
				\Decl{lg}{entier}\;
				sommeBonne \Gets true\;
				lg \Gets 0\;
				\While{lg<n ET sommeBonne}{
					sommeBonne \Gets (sommeLigne(carré,lg)=sommeRéférence)\;
					lg++\;
				}
				\Return sommeRéférence\;
			}
			\BlankLine
			\Algo{vérifierColonnes}{\Par{carré}{\Array{n $\times$ n}{entiers}},\Par{sommeRéférence}{entier}}{booléen}{
				\Decl{sommeBonne}{booléen}
				\Decl{col}{entier}\;
				sommeBonne \Gets true\;
				col \Gets 0\;
				\While{lg<m ET sommeBonne}{
					sommeBonne \Gets (sommeColonne(carré,col)=sommeRéférence)\;
					col++\;
				}
				\Return sommeRéférence\;
			}
		\end{algo}
	\end{Solution}	

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

	\begin{Solution}
		\begin{algo}
                  \Algo{pinceauZebre}{\Par{tab\InOut}{\Array{n $\times$ n}{entiers}}}{}{
                    \Assign{colDepart}{0}\;
                    \Fori[]{lg}{0}{n-1}{
                      \Fori[3]{col}{colDepart}{n-1}{
                        \Assign{tab[lg,col]}{NOIR}\;
                      }
                      \eIf{colDepart > 0 }{
                        \Assign{colDepart}{colDepart - 1}\;

                      }{
                        \Assign{colDepart}{2}\;
                      }

                    }
                  }
                  \Algo{pinceauSpirale}{\Par{tab\InOut}{\Array{n $\times$ n}{entiers}}}{}{
                    \Assign{lg}{0}\;
                    \Assign{col}{0}\;
                    \Assign{dirLg}{0}\;
                    \Assign{dirCol}{1}\;
                    \Assign{fini}{faux}\;
                    \While{NON fini}{
                      \Assign{tab[lg,col]}{NOIR}\;
                      \If{bord(lg,col,dirLg, dirCol) OU noircieDansDeuxCase(tab, lg,col,dirLg,dirCol) }{
                        tournerADroite(dirLg, dirCol)\;
                      }
                      avancer(lg, col, dirLg, dirCol)\;
                      \If{caseNoireADroite(tab,lg,col,dirLg, dirCol) }{
                        \Assign{fini}{vrai}\;

                      }
                    }
                  }
                  \Algo{bord}{\Par{lg, col, dirLg, dirCol}{entiers}}{booléen}{
                    \Assign{tmpLg}{lg}\;
                    \Assign{tmpCol}{col}\;
                    avancer(tmpLg, tmpCol, dirLg, dirCol)\;
                    \Return NON (0 <= tmpCol ET tmpCol < n ET 0 <= tmpLg ET tmpLg < n) \;
                  }
                  \Algo{noircieDansDeuxCase}{\Par{tab, lg, col, dirLg, dirCol}{entiers}}{booléen}{
                    \Assign{tmpLg}{lg}\;
                    \Assign{tmpCol}{col}\;
                    avancer(tmpLg, tmpCol, 2*dirLg, 2*dirCol)\;
                    \Return tab[tmpLg, tmpCol] == NOIR
                    \;
                  }
                \end{algo}
                \begin{algo}
                  \Algo{tournerADroite}{\Par{dirLg\InOut}{entier}, \Par{dirCol\InOut}{entier}}{}{
                    \Assign{dirLg}{dirCol}\;
                    \Assign{dirCol}{-dirLg}\;
                  }
                  \Comment{Tests: tournerADroite(0, 1) = (1, 0)}\;
                  \Comment{tournerADroite(1, 0) = (0, -1)}\;
                  \Comment{tournerADroite(0, -1)= (-1, 0)}\;
                  \Comment{tournerADroite(-1, 0)= (0, 1)}\;
                  \Algo{avancer}{\Par{lg\InOut}{entier}, \Par{col\InOut}{entier}, \Par{dirLg, dirCol}{entiers}}{}{
                    \Assign{lg}{lg + dirLg}\;
                    \Assign{col}{col + dirCol}\;
                  }
                  \Algo{caseNoireADroite}{\Par{tab, lg, col, dirLg, dirCol}{entiers}}{booléen}{
                    \Assign{tmpLg}{lg}\;
                    \Assign{tmpCol}{col}\;
                    \Assign{tmpDirLg}{dirLg}\;
                    \Assign{tmpDirCol}{dirCol}\;
                    tournerADroite(tmpDirLg, tmpDirCol)\;
                    \eIf{NON bord(lg,col, tmpDirLg, tmpDirCol) }{
                      avancer(tmpLg, tmpCol, dirLg, dirCol)\;
                      \Return  tab[tmpLg, tmpCol] = NOIR \;
                    }{
                      \Return  faux \;
                    }
                  }
		\end{algo}
	\end{Solution}

\refstepcounter{Exercice}

\chapter{L'orienté objet}
\chapter{La liste}
\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\chapter{Les traitements de rupture}
\refstepcounter{Exercice}

\begin{Solution}
  \begin{algo}
    \Structure{Date}{
      \Decl{année, mois, jour}{entiers}\;
    }
    \Structure{Job}{
      \Decl{login}{chaîne}\;
      \Decl{date}{Date}\;
      \Decl{nombre}{entier}\;
    }
    \Algo{stopGaspi}{\Par{jobs}{Liste de Job}, \Par{limitePrn}{entier}}{}{
      \Comment{jobs est triée en majeur sur le login}\;
      \Decl{i}{entier}\;
      \Decl{cptPrn}{entier}\;
      \Decl{saveLogin}{chaîne}\;
      \While{i < jobs.taille() }{
        \Assign{cptPrn}{0}\;
        \Assign{saveLogin}{jobs.get(i).login}\;
        \While{i < jobs.taille() ET jobs.get(i).login = saveLogin }{
          \Assign{cptPrn}{cptPrn + jobs.get(i).nombre}\;
          \Assign{i}{i + 1}\;
        }
        \If{cptPrn > limitePrn }{
          \Write  "Alerte : " + saveLogin + " " + cptPrn\;
        }
      }
    }
  \end{algo}
\end{Solution}

\refstepcounter{Exercice}

\begin{Solution}
  \begin{algo}
    \Algo{RuptureNiveau2}{\Par{etudiants}{liste d’ Etudiant}}{}{
      \Comment{on suppose les données classées en majeur sur l’option}\;
      \Comment{et en mineur sur la date de naissance (ordre chronologique)}\;
      \Decl{etd}{Etudiant}\;
      \Decl{saveOption}{chaine}\;
      \Decl{saveAnnéeNaissance}{entier}\;
      \Decl{cpt, cptOpt}{entier} \Comment{ICI}\;
      \Decl{i}{entier}\;
      \Assign{i}{0}\;
      \While{i < etudiants.taille() }{
        \Assign{saveOption}{etd.option}\;
        \Assign{cptOpt}{0} \Comment{ICI}\;
        \While{i < etudiants.taille() ET etudiants.get(i).option = saveOption }{
          \Assign{saveAnnéeNaissance}{etudiants.get(i).dateNaissance.année}\;
          \Assign{cpt}{0}\;
          \While{i < etudiants.taille()
             ET etudiants.get(i).option = saveOption
             ET etudiants.get(i).dateNaissance.année = saveAnnéeNaissance}{
            \Assign{cpt}{cpt + 1}\;
            \Assign{cptOpt}{cptOpt + 1} \Comment{ICI}\;
            \Assign{i}{i + 1}\;
          }
          \Write  cpt, " étudiant(s) dans l’option ", saveOption, " est(sont) né(s) en ", saveAnneeNaissance\;
        }
        \Write  cptOpt, " étudiant(s) dans l'option ", saveOption \Comment{ICI}\;
      }
    }
\end{algo}
\end{Solution}

\refstepcounter{Exercice}

\begin{Solution}
  \begin{algo}
\Algo{afficherComptageEtudiants}{\Par{etudiants}{liste d' Etudiants}}{}{
  \Decl{saveOption, saveBloc}{chaine}\;
  \Decl{cptEtudiantOption, cptEtudiantBloc, i}{entier}\;
  \Assign{i}{0}\;
  \While{i < etudiants.taille() }{
    \Assign{saveOption}{etudiants.get(i).option}\;
    \Comment{initialisation pré-rupture 1}\;
    \Assign{cptEtudiantOption}{0}\;
    \Write  saveOption\;
    \While{i < etudiants.taille() ET (etudiants.get(i)).option = saveOption }{
      \Assign{saveBloc}{etudiants.get(i).bloc}\;
      \Comment{initialisation pré-rupture 2}\;
      \Assign{cptEtudiantBloc}{0}\;
      \While{i < etudiants.taille() ET etudiants.get(i).option = saveOption ET etudiants.get(i).bloc = saveBloc }{
        \Comment{traitement des éléments de la liste}\;
        \Assign{cptEtudiantBloc}{cptEtudiantBloc + 1}\;
        \Assign{i}{i + 1}\;
      }
      \Comment{traitement post-rupture 2}\;
      \Assign{cptEtudiantOption}{cptEtudiantOption + cptEtudiantBloc}\;
      \Write  "    bloc " + saveBloc + " : " + cptEtudiantBloc + " étudiants"\;
    }
    \Comment{traitement post-rupture 1}\;
    \Write  "    TOTAL  : " + saveOption + " étudiants"\;
  }
}


\end{algo}

\end{Solution}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\begin{Solution}
\begin{algo}
  \Algo{club}{\Par{membres}{Liste de Participant}}{}{
    \Decl{n}{entier}\;
    \Decl{mineur}{booléen}\;
    \Decl{saveNom, saveRef}{chaîne}\;
    \Decl{accumRésultat, nbResultats}{entier}\;
    \Decl{nbMineursClub}{entier}\;
    \Assign{n}{membres.taille()}\;
    \Assign{i}{0}\;
    \While{i < n }{
      \Assign{saveRef}{membres.get(i).reference}\;
      \Assign{nbMineursClub}{0}\;
      \Write  "Participations de mineurs du club " + saveRef\;
      \While{i < n ET saveRef = membres.get(i).reference }{
        \Assign{saveNom}{membres.get(i).nom}\;
        \Assign{accumRésultat}{0}\;
        \Assign{nbResultats}{0}\;
        \Assign{mineur}{membres.get(i).age < 18}\;
        \While{i < n ET saveRef = membres.get(i).reference ET saveNom = membres.get(i).nom }{
          \Assign{accumRésultat}{accumRésultat + membres.get(i).resultat}\;
          \Assign{nbResultats}{nbResultats + 1}\;
          \Assign{i}{i + 1}\;
        }
        \If{mineur }{
          \Assign{nbMineursClub}{nbMineursClub + 1}\;
          \Write  saveNom + accumRésultat/nbResultats\;
        }
      }
      \eIf{nbMineursClub > 0 }{
        \Write  "Nombre total de membres mineurs de ce club : " + nbMineursClub\;
      }{
        \Write  "Pas de participations de mineurs pour ce club"\;
      }
    }
  }
\end{algo}
\end{Solution}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\chapter{Représentation des données\index{Representation des données@Représentation des données}}
\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\begin{Solution}
  Solution incomplète
  \begin{algo}
    \Comment{tab est un tableau de caractères}\;
    \Comment{chaque caractère est soit:}\;
    \Comment{- une lettre (la lettre)}\;
    \Comment{- un point   (case noircie)}\;
    \Comment{- une espace (case libre)}\;

    \Algo{placerLettre}{\Par{i, j}{entiers}, \Par{lettre}{caractère}, \Par{tab}{tableau de m x n caractères}}{}{
      \eIf{NON estCaseOccupée() }{
        \Assign{tab}{lettre}\;
      }{
        \Error  "Case déjà occupée"\;
      }
    }

    \Algo{estCaseOccupée}{\Par{i, j}{entiers}, \Par{tab}{tableau de m x n caractères}}{booléen}{
      \Return  tab[i,j] != ' '\;
    }
  \end{algo}
\end{Solution}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

