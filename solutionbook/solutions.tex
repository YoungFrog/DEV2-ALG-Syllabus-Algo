\chapter{Les tableaux à 2 dimensions}
\refstepcounter{Exercice}

		\begin{Solution}
			\begin{algo}
				\Algo{estNul}{\Par{tab}{\Array{n $\times$ m}{integers}}, \Par{lg, col}{integers}}{boolean}{
					\Return tab[lg][col]=0\;
				}
			\end{algo}
		\end{Solution}

\refstepcounter{Exercice}

		\begin{Solution}
			\begin{algo}
				\Algo{assigner}{\Par{tab\InOut}{\Array{n $\times$ m}{integers}}, \Par{lg\In, col\In, val\In}{integers}}{}{
					\If{estNul(tab, lg, col)}{
						tab[lg,col] \Gets val\;
					}
				}
			\end{algo}
		\end{Solution}

\refstepcounter{Exercice}

		\begin{Solution}
			% \begin{Console}
			% 	algorithme estBordBas(tab : tableau de n x m entiers, lg, col : entiers) -> booléen
			% 		retourner lg = n - 1
			% 	fin algorithme
			% 	algorithme estBordGauche(tab : tableau de n x m entiers, lg, col : entiers) -> booléen
			% 		retourner col = 0
			% 	fin algorithme
			% 	algorithme estBordHaut(tab : tableau de n x m entiers, lg, col : entiers) -> booléen
			% 		retourner lg = 0
			% 	fin algorithme
			% 	algorithme estBordDroit(tab : tableau de n x m entiers, lg, col : entiers) -> booléen
			% 		retourner col = m - 1
			% 	fin algorithme
		
			% 	algorithme estBord(tab : tableau de n x m entiers, lg, col : entiers) -> booléen
			% 		retourner estBordBas(tab, lg, col) OU estBordGauche(tab, lg, col) OU
			% 					estBordDroit(tab, lg, col) OU estBordHaut(tab, lg, col)
			% 	fin algorithme
			% \end{Console}
		\end{Solution}

\refstepcounter{Exercice}

		\begin{Solution}
			% \begin{Console}
			% algorithme estCoinHG(tab : tableau de n x m entiers, lg, col : entiers) -> booléen
			% 	retourner estBordGauche(tab, lg, col) ET estBordHaut(tab, lg, col)
			% fin algorithme
			% algorithme estCoinHD(tab : tableau de n x m entiers, lg, col : entiers) -> booléen
			% 	retourner estBordDroit(tab, lg, col) ET estBordHaut(tab, lg, col)
			% fin algorithme
			% algorithme estCoinBG(tab : tableau de n x m entiers, lg, col : entiers) -> booléen
			% 	retourner estBordGauche(tab, lg, col) ET estBordBas(tab, lg, col)
			% fin algorithme
			% algorithme estCoinBD(tab : tableau de n x m entiers, lg, col : entiers) -> booléen
			% 	retourner estBordDroit(tab, lg, col) ET estBordBas(tab, lg, col)
			% fin algorithme
			
			% algorithme estCoin(tab : tableau de n x m entiers, lg, col : entiers) -> booléen
			% 	retourner estCoinHG(tab, lg, col) OU estCoinHD(tab, lg, col) OU
			% 			  estCoinBD(tab, lg, col) OU estCoinBG(tab, lg, col)
			% fin algorithme
			% \end{Console}
		\end{Solution}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

	\begin{Solution}
	% 	\begin{Console}
	% algorithme afficherCasesAdjacentes(tab: tableau de n entiers, lg, col : entiers)
	% 	si NON estBordGauche(tab, lg, col) alors
	% 		afficher lg, col-1
	% 	fin si
	% 	si NON estBordDroit(tab, lg, col) alors
	% 		afficher lg, col+1
	% 	fin si
	% 	si NON estBordHaut(tab, lg, col) alors	
	% 		afficher lg - 1, col
	% 	fin si
	% 	si NON estBordBas(tab, lg, col) alors
	% 		afficher lg + 1, col
	% 	fin si
	% fin algorithme
	% 	\end{Console}
	\end{Solution}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

	\begin{Solution}
		% \begin{Console}
		% 	algorithme pinceauZebre(tab IN OUT : tableau de n x n entiers)
		% 	colDepart <- 0
		% 	pour lg de 0 à n-1 faire
		% 		pour col de colDepart à n-1 par 3 faire
		% 			tab[lg,col] <- NOIR
		% 		fin pour
		% 		si colDepart > 0 alors
		% 			colDepart <- colDepart - 1
		% 		sinon
		% 			colDepart <- 2
		% 		fin si
		% 	fin pour
		% fin algorithme
		
		% algorithme pinceauSpirale(tab IN OUT : tableau de n x n entiers)
		% 	lg <- 0
		% 	col <- 0
		% 	dirLg <- 0
		% 	dirCol <- 1
		% 	fini <- faux
		% 	tant que NON fini faire
		% 		tab[lg,col] <- NOIR
		% 		si bord(lg,col,dirLg, dirCol) OU
		% 			noircieDansDeuxCase(tab, lg,col,dirLg,dirCol) alors 
		% 			tournerADroite(dirLg, dirCol)
		% 		fin si
		% 		avancer(lg, col, dirLg, dirCol)
		% 		si caseNoireADroite(tab,lg,col,dirLg, dirCol) alors
		% 			fini <- vrai
		% 		fin si
		% 	fin tant que
		% fin algorithme
		% algorithme bord(lg,col,dirLg, dirCol) -> booléen
		% 	tmpLg <- lg
		% 	tmpCol <- col
		% 	avancer(tmpLg, tmpCol, dirLg, dirCol)
		% 	retourner 0 <= tmpCol ET tmpCol < n ET 0 <= tmpLg ET tmpLg < n
		% fin algorithme
		% algorithme noircieDansDeuxCase(tab, lg,col,dirLg, dirCol) -> booléen
		% 	tmpLg <- lg
		% 	tmpCol <- col
		% 	avancer(tmpLg, tmpCol, dirLg, dirCol)
		% 	retourner tab[tmpLg, tmpCol] = NOIR
		% fin algorithme
		% algorithme tournerADroite(dirLg IN OUT : entier, dirCol IN OUT : entier)
		% 	dirLg <- dirCol
		% 	dirCol <- -dirLg
		% fin algorithme
		
		% //Tests: tournerADroite(0, 1) = (1, 0)
		% //		 tournerADroite(1, 0) = (0, -1)
		% //		 tournerADroite(0, -1)= (-1, 0)
		% //		 tournerADroite(-1, 0)= (0, 1)
		% algorithme avancer(lg IN OUT : entier, col IN OUT : entier, dirLg, dirCol : entiers)
		% 	lg <- lg + dirLg
		% 	col <- col + dirCol
		% fin algorithme
		% algorithme caseNoireADroite(tab,lg,col, dirLg, dirCol) -> booléen
		% 	tmpLg <- lg
		% 	tmpCol <- col
		% 	tmpDirLg <- dirLg
		% 	tmpDirCol <- dirCol
		% 	tournerADroite(tmpDirLg, tmpDirCol)
		% 	si NON bord(lg,col, tmpDirLg, tmpDirCol) alors
		% 		avancer(tmpLg, tmpCol, dirLg, dirCol)
		% 		retourner tab[tmpLg, tmpCol] = NOIR
		% 	sinon
		% 		retourner faux
		% 	fin si
		% fin algorithme
		% \end{Console}
	\end{Solution}

\refstepcounter{Exercice}

\chapter{L'orienté objet}
\chapter{La liste}
\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\chapter{Les traitements de rupture}
\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\chapter{Représentation des données\index{Representation des données@Représentation des données}}
\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

\refstepcounter{Exercice}

