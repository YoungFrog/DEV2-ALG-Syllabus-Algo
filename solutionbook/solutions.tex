\chapter{Les tableaux à 2 dimensions}
		\begin{Exercice}{Case nulle ?}
			Écrire un algorithme qui reçoit un tableau d'entiers
			(à $n$ lignes et $m$ colonnes)
			ainsi que les coordonnées d'une case (ligne, colonne)
			et qui retourne un booléen indiquant si la case désignée
			contient ou pas la valeur nulle.
			
			\begin{algo}
				\AlgoSign{estNul}{\Par{tab}{\Array{n $\times$ m}{integers}}, \Par{lg, col}{integers}}{boolean}\;
			\end{algo}
		\end{Exercice}

		\begin{Solution}
			\begin{algo}
				\Algo{estNul}{\Par{tab}{\Array{n $\times$ m}{integers}}, \Par{lg, col}{integers}}{boolean}{
					\Return tab[lg][col]=0\;
				}
			\end{algo}
		\end{Solution}

		\begin{Exercice}{Assigner une case}
			Écrire un algorithme qui reçoit un tableau d'entiers
			(à $n$ lignes et $m$ colonnes)
			ainsi que les coordonnées d'une case (ligne, colonne)
			et une valeur entière.
			L'algorithme met la valeur donnée dans la case indiquée
			pour autant que la case contienne actuellement la valeur nulle.
			Dans le cas contraire, l'algorithme ne fait rien.
			
			\begin{algo}
				\AlgoSign{assigner}{\Par{tab\InOut}{\Array{n $\times$ m}{integers}}, \Par{lg\In, col\In, val\In}{integers}}{}\;
			\end{algo}
		\end{Exercice}

		\begin{Exercice}{Un bord du tableau}
			Écrire un algorithme qui reçoit un tableau d'entiers
			(à $n$ lignes et $m$ colonnes)
			ainsi que les coordonnées d'une case (ligne, colonne).
			L'algorithme doit indiquer si la case donnée
			est ou non sur un \textbf{bord} du tableau.
			
			\begin{algo}
				\AlgoSign{estBord}{\Par{tab}{\Array{n $\times$ m}{integers}}, \Par{lg, col}{integers}}{boolean}\;
			\end{algo}
		\end{Exercice}

		\begin{Exercice}{Un coin du tableau}
			Écrire un algorithme qui reçoit un tableau d'entiers
			(à $n$ lignes et $m$ colonnes)
			ainsi que les coordonnées d'une case (ligne, colonne).
			L'algorithme doit indiquer si la case donnée
			est ou non sur un des 4 \textbf{coins} du tableau.
			
			\begin{algo}
				\AlgoSign{estCoin}{\Par{tab}{\Array{n $\times$ m}{integers}}, \Par{lg, col}{integers}}{boolean}\;
			\end{algo}
		\end{Exercice}

	\begin{Exercice}{Affichage}\marginicon{java}%
		Écrire un algorithme qui affiche tous les éléments d'un
		tableau (à $n$ lignes et $m$ colonnes) ligne par ligne.
		
		Écrivez un autre algorithme qui affiche cette fois les éléments
		colonne par colonne
	\end{Exercice}

	\begin{Exercice}{Cases adjacentes}
		Écrire un algorithme qui reçoit un tableau d'entiers
		(à $n$ lignes et $m$ colonnes)
		ainsi que les coordonnées d'une case (ligne, colonne)
		et \emph{affiche} les coordonnées
		des cases \emph{adjacentes}.		
	\end{Exercice}

	\begin{Exercice}{Les nuls}\marginicon{java}%
		Écrire un algorithme qui reçoit un tableau ($n$ x $m$)
		d'entiers et qui retourne la proportion
		d'éléments nuls dans ce tableau.
	\end{Exercice}

	\begin{Exercice}{Le tableau de cotes}
		Soit un tableau à $n$ lignes et $m$ colonnes d'entiers où
		une ligne représente les notes sur 20 d'un étudiant et
		les colonnes toutes les notes d'un cours.
		
		Écrire un algorithme recevant ce tableau en paramètre et retournant le
		pourcentage d'étudiants ayant obtenu une moyenne
		supérieure à 50\%.
	\end{Exercice}

	\begin{Exercice}{Le triangle de Pascal}
		\marginicon{java}%
		Le triangle de Pascal est construit de la façon suivante :
		\begin{itemize}
		\item la ligne initiale contient un seul élément de valeur 1 ;
		\item chaque ligne possède un élément de plus que la précédente ;
		\item chaque ligne commence et se termine par 1 ;
		\item 
			pour calculer un nombre d’une autre case du tableau, on additionne le
			nombre situé dans la case située juste au-dessus avec celui dans la
			case à la gauche de la précédente.
		\end{itemize}
	
		Écrire un algorithme qui reçoit en paramètre un entier
		$n$, et qui renvoie un tableau contenant les
		$n+1$ premières lignes du triangle de Pascal
		(indicées de $0$ à $n$).

		\begin{minipage}[t][][t]{6cm}	
		N.B.: le «~triangle~» sera bien entendu renvoyé dans un tableau carré
		(ce qui ne sera forcément le cas en Java).
		Quid des cases non occupées ?
		
		\medskip
		Par exemple, pour $n$ qui vaut 5, on aura le tableau ci-contre.
		\end{minipage}
		~
		\begin{minipage}[t][][b]{8cm}	
		\begin{center}
		\begin{tabular}{|*{6}{>{\centering\arraybackslash}m{0.35cm}|}}
		\hline
		 1 & ~ & ~ & ~ & ~ & ~ \\\hline
		 1 & 1 & ~ & ~ & ~ & ~ \\\hline
		 1 & 2 & 1 & ~ & ~ & ~ \\\hline
		 1 & 3 & 3 & 1 & ~ & ~ \\\hline
		 1 & 4 & 6 & 4 & 1 & ~ \\\hline
		 1 & 5 & 10 & 10 & 5 & 1 \\\hline
		\end{tabular}
		\end{center}
		\end{minipage}
	\end{Exercice}

	\begin{Exercice}{Tous positifs}
		\marginicon{java}%
		Écrire un algorithme qui reçoit un tableau ($n$ x $m$) d’entiers et qui vérifie
		si tous les nombres qu’il contient sont strictement positifs. Bien sûr,
		on veillera à éviter tout travail inutile; la rencontre d’un nombre
		négatif ou nul doit arrêter l'algorithme.
	\end{Exercice}

	\begin{Exercice}{Toute une ligne de valeurs non nulles ?}
		Écrire un algorithme qui reçoit un tableau d'entiers
		(à $n$ lignes et $m$ colonnes)
		ainsi qu'un numéro de ligne
		et qui retourne un booléen indiquant si la ligne donnée du tableau
		ne contient que des valeurs non nulles.
		
		\begin{algo}
			\AlgoSign{lignePleine}{\Par{tab}{\Array{n $\times$ m}{integers}}, \Par{lg}{integer}}{boolean}\;
		\end{algo}
		
		Faites de même pour une colonne.
	\end{Exercice}

	\begin{Exercice}{Le carré magique}
		\marginicon{java}%
		Un carré magique est un tableau d’entiers carré
		(c'est-à-dire possédant autant de lignes que de
		colonnes) ayant la propriété suivante: si on additionne les éléments
		d'une quelconque de ses lignes, de ses colonnes ou de
		ses deux diagonales, on obtient à chaque fois le même résultat.
		
		Écrire un algorithme recevant en paramètres le tableau ($n$ x $n$)
		d'entiers représentant le carré et renvoyant une valeur booléenne
		indiquant si c'est un carré magique ou pas.
	\end{Exercice}

	\begin{Exercice}{Lignes et colonnes}
		Écrire un algorithme qui reçoit un tableau d’entiers à 2 dimensions en paramètre 
		et qui retourne un booléen indiquant si ce tableau 
		possède 2 lignes ou 2 colonnes identiques.
		
		Dans l’affirmative, 
		cet algorithme renverra également en paramètres les informations suivantes :
		\begin{itemize}
		\item les indices des lignes ou colonnes identiques
		\item un caractère valant ‘L’ ou ‘C’ selon qu’il s’agit de lignes ou de
		colonnes
		\end{itemize}
		
		Dans la négative, les valeurs de ces paramètres seront indéterminées ou
		quelconques, elles ne seront de toute façon pas utilisées par l'algorithme
		appelant.
	\end{Exercice}

	\begin{Exercice}{Le contour du tableau}
		On donne un tableau d’entiers \lda{tabEnt} 
		à $n$ lignes et $m$ colonnes. 
		Écrire un algorithme retournant la somme 
		de tous les éléments \textit{impairs}
		situés sur le bord du tableau.
	
		Exemple : pour le tableau suivant, l'algorithme doit renvoyer $32$
	
		\begin{center}
		\begin{tabular}{|*{4}{>{\centering\arraybackslash}m{0.6cm}|}}
		  \hline
		  3 & 4 & 6 & 11\\\hline
		  2 & 21 & 7 & 9\\\hline
		  1 & 5 & 12 & 3\\\hline
		\end{tabular}
		\end{center}
	
		Et pour le suivant, l'algorithme doit renvoyer $6$
	
		\begin{center}
		\begin{tabular}{|*{5}{>{\centering\arraybackslash}m{0.3cm}|}}
		\hline
		 4 & 1 & 2 & 8 & 5\\\hline
		\end{tabular}
		\end{center}
	\end{Exercice}

	\begin{Exercice}{À vos pinceaux !}
		On possède un tableau à $n$ lignes et $n$ colonnes dont les éléments de type
		Couleur valent NOIR ou BLANC. On suppose que le tableau est initialisé
		à BLANC au départ. Écrire un algorithme qui \emph{noircit} les cases de ce
		tableau comme le suggèrent les dessins suivants~(les exemples sont
		donnés pour un tableau 10 x 10 mais les algorithmes doivent fonctionner
		quelle que soit la taille du tableau).
		
		\begin{center}
		\includegraphics[width=0.7\textwidth]{image/tab2d-ex-oxz}
		\includegraphics[width=0.7\textwidth]{image/tab2d-ex-zts}
		\end{center}
		
		Notes
		\begin{itemize}
		\item 
			Le zèbre doit toujours présenter des lignes
			obliques et parallèles, quelle que soit la taille.
		\item
			La spirale est un véritable défi
			et vous est donné comme exercice facultatif.
			Ne le faites pas si vous êtes en retard.
		\end{itemize}
		
	\end{Exercice}

	\begin{Exercice}{Exercices sur la complexité}	
		Quelle est la complexité 
		\begin{enumerate}[label=\alph*)]
		\item 
			d’un algorithme de parcours	d'un tableau $n$ x $n$ ?
		\item
			des algorithmes que vous avez écrits pour les exercices :
			"Les nuls", "Tous positifs", "Le carré magique"
			et "Le contour d'un tableau" ?
		\item 
			des algorithmes que vous avez écrits pour résoudre les
			exercices du pinceau ?
		\end{enumerate}
	\end{Exercice}

\chapter{L'orienté objet}
\chapter{La liste}
		\begin{Exercice}{Manipulation d'une liste}
			Écrire un algorithme qui crée la liste suivante :
			\begin{enumerate}[start=0]
			\item 494
			\item 209
			\item 425
			\end{enumerate}
			affiche sa taille, demande si la valeur 425 est présente, 
			supprime la valeur 209 puis insère la valeur 101 en tête de liste.
		\end{Exercice}

		\begin{Exercice}{Liste des premiers entiers}
			Écrire un algorithme qui reçoit un entier $n$ en paramètre et retourne la
			liste contenant les entiers de 1 à $n$ dans l'ordre
			décroissant. On peut supposer que $n$ est strictement positif.
		\end{Exercice}

		\begin{Exercice}{Somme d'une liste}
			\marginicon{java}%
			Écrire un algorithme qui calcule la somme des éléments d’une liste
			d’entiers.
		\end{Exercice}

		\begin{Exercice}{Anniversaires}
			Écrire un algorithme qui reçoit une liste de structure Personne 
			(nom + prénom + date de naissance) et retourne la liste
			de ceux qui sont nés durant un mois passé en paramètre 
			(donné sous la forme d'un entier entre 1 et 12).
		\end{Exercice}

		\begin{Exercice}{Concaténation de deux listes}
			\marginicon{java}%
			Écrire un algorithme qui reçoit 2 listes et ajoute
			à la suite de la première les éléments de la seconde; la seconde liste
			n'est pas modifiée par cette opération.
		\end{Exercice}

		\begin{Exercice}{Le nettoyage}
			Écrire un algorithme qui reçoit une liste de chaines en paramètre et
			supprime de cette liste tous les éléments de valeur donnée en
			paramètre. L'algorithme retournera le nombre de
			suppressions effectuées.
		\end{Exercice}

		\begin{Exercice}{Les extrêmes}
			\marginicon{java}
			Écrire un algorithme qui supprime le minimum et le maximum des éléments
			d’une liste d’entiers. On peut supposer que le maximum et le minimum
			sont uniques.
		\end{Exercice}

		\begin{Exercice}{Fusion de deux listes}
			\marginicon{java}%
			Soit deux listes \textbf{triées}
			d'entiers (redondances possibles). Écrire un algorithme
			qui les fusionne. Le résultat est une liste encore triée contenant
			tous les entiers des deux listes de départ (qu'on
			laisse inchangées).
			
			Exemple : Si les 2 listes sont (1, 3, 7, 7) et (3, 9), 
			le résultat est (1, 3, 3, 7, 7, 9).
		\end{Exercice}

		\begin{Exercice}{Éliminer les doublons d'une liste}
			\marginicon{java}%
			Soit une liste \textbf{triée} 
			d'entiers avec de possibles redondances. Écrire un
			algorithme qui enlève les redondances de la liste.
					
			Exemple : Si la liste est (1, 3, 3, 7, 8, 8, 8),
			le résultat est (1, 3, 7, 8).
	
			\begin{enumerate}[label=\alph*)]
				\item 
					Faites l'exercice en créant une \textbf{nouvelle
					liste} (la liste de départ reste inchangée)
				\item 
					Refaites l'exercice en \textbf{modifiant}
					la liste de départ (pas de nouvelle liste)
			\end{enumerate}
		\end{Exercice}

		\begin{Exercice}{Rendez-vous}
			Soit la structure \lda{RendezVous} composée 
			d’une date (cf. la structure Date du cours de DEV1)
			et d’un motif de rencontre. 
			
			\begin{algo}
				\Structure{RendezVous}{
					\Decl{date}{Date}\;
					\Decl{motif}{string}\;
				}
			\end{algo}

			Écrire un algorithme qui reçoit une liste de rendez-vous 
			et la met à jour en supprimant tous ceux qui sont désormais passés. 			
			
			Pour résoudre cet exercice, vous pouvez utiliser sans l'écrire
			un algorithme \lda{aujourdhui()} qui retourne la date du jour.
		\end{Exercice}

\chapter{Les traitements de rupture}
\begin{Exercice}{La chasse au gaspi [rupture de niveau 1]}
	À l’ÉSI, les quantités de feuilles imprimées et photocopiées 
	par les professeurs et les étudiants sont enregistrées à des fins de traitement.
	Le service technique désirant facturer les «~exagérations~», 
	vous fournit une liste de toutes les impressions effectuées depuis le début de l'année.
	Cette liste présente la structure d’enregistrement \lda{Job} suivante 
	et est ordonnée alphabétiquement \textbf{en majeur} sur le champ \lda{login}  :

	\begin{algo}
		\Structure{Job}{
			\Decl{login}{string}\;
			\Decl{date}{date}\;
			\Decl{nombre}{integer}\;
		}
	\end{algo}

	Écrire un algorithme permettant d'afficher une ligne par
	utilisateur dont le nombre total de feuilles imprimées dépasse une
	valeur limite entrée en paramètre. 
	Cette ligne contiendra le login et le nombre.
\end{Exercice}

\begin{Exercice}{Compter le nombre d'étudiants par option}
	Reprenons l'exemple donné pour la rupture de niveau 2 (\lda{RuptureNiveau2}, page \pageref{algo:rupt2}).
	Que faut-il ajouter à l'algorithme pour qu'il affiche également 
	le nombre total d'étudiants par option ?
\end{Exercice}

\begin{Exercice}{Compter les étudiants [rupture de niveau 2]}
	
	Supposons que la structure \lda{Etudiant} contienne également
	un champ indiquant dans quel bloc se trouve l'étudiant (1, 2 ou 3).
	On voudrait un algorithme qui reçoit une liste d'étudiants et calcule
	le nombre d'étudiants dans chaque section et, par section, dans chaque bloc.
	
	L'affichage ressemblera à :
	{\small
	\begin{verbatim}
    Gestion
        bloc 1 : 130 étudiants
        bloc 2 : 42 étudiants
        bloc 3 : 16 étudiants
        TOTAL  : 188 étudiants
    Industriel
        bloc 1 : 32 étudiants
        bloc 2 : 14 étudiants
        bloc 3 : 8 étudiants
        TOTAL  : 54 étudiants
    Réseau
        bloc 1 : 82 étudiants
        bloc 2 : 31 étudiants
        bloc 3 : 13 étudiants
        TOTAL  : 126 étudiants
	\end{verbatim}
	}
	\begin{enumerate}[label=\alph*)]
		\item 
		Quel doit-être le tri de la liste pour pouvoir résoudre cet exercice
		avec un algorithme de rupture ?
		\item 
		Écrire cet algorithme.
	\end{enumerate}
\end{Exercice}

%\begin{Exercice}{Statistiques de ventes de voitures [rupture de niveau 2]}
%	Un grand quotidien dispose d’une liste 
%	regroupant les ventes de voitures neuves pendant l’année dernière. 
%	Les éléments de cette liste sont de type \textsl{Voiture} dont voici la définition :
%
%	\begin{algo}
%	\Structure{Voiture}
%		\Decl{plaque}{chaine} 	\RComment{numéro d’immatriculation}\;
%		\Decl{marque}{chaine} 	\RComment{marque de la voiture (par ex. «~Citroën~»)}\;
%		\Decl{type}{chaine}		\RComment{type de modèle dans la marque (par ex. «~Berlingo~»)}\;
%		\Decl{nom}{chaine}		\RComment{nom du propriétaire}\;
%		\Decl{adresse}{chaine}	\RComment{adresse du propriétaire}\;
%		\Decl{date}{date}		\RComment{date de la demande d’immatriculation}\;
%	\EndStruct
%	\end{algo}
%
%	La liste est ordonnée croissant \textbf{en majeur sur la marque de
%	voiture et en mineur sur le type}. 
%
%	Afin de préparer le travail des journalistes, 
%	il a été demandé au service informatique de préparer un affichage 
%	qui globalise les ventes de voiture par marque 
%	et pour chaque marque, par type. 
%	Cet affichage contiendra les renseignements suivants :
%
%	\begin{itemize}
%		\item 
%			un titre général \og{}Ventes de voitures neuves en 2017\fg{} 
%		\item 
%			pour chaque marque :
%			\begin{itemize}
%				\item 
%					le nom de la marque
%				\item 
%					pour chaque type de modèle
%                \begin{itemize} 
%        			\item 
%		      			le nom de ce type et le nombre de voitures neuves vendues
%                \end{itemize}				
%				\item 
%					le nombre total de voitures vendues pour cette marque
%			\end{itemize}
%		\item 
%			enfin, le total global du nombre de voitures vendues toutes marques
%			confondues
%	\end{itemize}
%	
%	Écrivez un algorithme produisant l'affichage décrit.
%\end{Exercice}

\begin{Exercice}{Les fanas d'info  [rupture de niveau 2]}

	Une grande société d’informatique a organisé durant les douze derniers
	mois une multitude de concours ouverts aux membres de clubs d’informatique. 
	Elle souhaiterait récompenser le club qui aura été le plus «~méritant~» 
	durant cette période au point de vue de la participation des membres mineurs. 
	Chaque résultat individuel des participants (y compris des majeurs) est repris dans une liste
	dont les éléments sont de type \lda{Participant}.

	\begin{algo}
	\Structure{Participant}{
		\Decl{nom}{string} 		\RComment{nom et prénom du participant}
		\Decl{âge}{integer} 		\RComment{âge du participant au moment du concours}
		\Decl{référence}{string}\RComment{référence du club auquel appartient ce participant}
		\Decl{numéro}{integer}	\RComment{numéro du concours auquel il a participé}
		\Decl{résultat}{integer}	\RComment{résultat obtenu lors de ce concours (sur 100)}
	}
	\end{algo}

	Sachant que la liste est ordonnée \textbf{en majeur sur le champ \textsf{référence}
	et en mineur sur le champ \lda{nom}}, 
	on demande d’écrire l’algorithme qui affiche les informations suivantes :

	pour chaque club :
	\begin{itemize}
		\item 
			sa référence
		\item 
			pour chaque membre mineur de ce club :
        \begin{itemize}
		    \item 
			   son nom et prénom
		    \item 
			   la cote moyenne sur 100 des concours auquel ce membre a participé
        \end{itemize}
		\item 
			le nombre total de participations des membres mineurs
	\end{itemize}
	
	\textbf{N.B.~:} un membre mineur qui s’est inscrit à un concours = une
	participation. Un club qui n’aura eu aucun membre mineur participant
	figurera quand même dans le résultat avec la mention 
	\og{}Pas de participation de membre mineur\fg{}. 
	Par contre, un club dont aucun membre n’a participé au moindre concours ne sera pas affiché.

	À la fin, on affichera la référence du meilleur club, à savoir celui qui
	a eu la plus haute cote moyenne de membres mineurs 
	(simplifions on ne gérant pas les possibles ex-\ae{}quo).

\end{Exercice}

\begin{Exercice}{Éliminer les doublons d'une liste.}
	Soit une liste ordonnée d'entiers avec des possibles redondances. 
	Écrire un algorithme qui enlève les redondances de la liste. 
	On vous demande de créer une nouvelle liste (la liste de départ reste inchangée).
	
	Exemple : si la liste est $(1, 3, 3, 7, 8, 8, 8)$ 
	le résultat sera $(1, 3, 7, 8)$.
\end{Exercice}

\begin{Exercice}{Une suite logique}
	Voici une petite suite logique :
	
	\begin{minipage}{5cm}
		\small
		\begin{verbatim}
	1
	1 1
	2 1
	1 2 1 1
	1 1 1 2 2 1
	3 1 2 2 1 1
	1 3 1 1 2 2 2 1
	1 1 1 3 2 1 3 2 1 1
	3 1 1 3 1 2 1 1 1 3 1 2 2 1
	...
		\end{verbatim}
	\end{minipage}
	\begin{minipage}{9cm}
		\begin{enumerate}[label=\alph*)]
		\item
			Comprendre la logique derrière cette suite 
			et écrire la ligne suivante.
		\item
			Écrire un algorithme qui reçoit une ligne 
			(sous forme d'une liste d'entiers) 
			et retourne la ligne suivante 
			(sous forme d'une autre liste d'entiers).
			Votre première tâche sera probablement de comprendre 
			ce que vient faire cet exercice dans le chapitre des ruptures puisque la liste n'est pas triée.
		\item
			Écrire l'algorithme qui reçoit $N$ (un entier) 
			et affiche les $N$ premières lignes de cette suite logique.	
		\end{enumerate}
	\end{minipage}
\end{Exercice}

\begin{Exercice}{Alternative à la rupture}
	Reprenons l'exemple donné pour la rupture de niveau 1 (\lda{RuptureNiveau1}, page \pageref{algo:rupt1}).
	Supposons que la liste ne soit \textbf{pas} triée sur l'option.
	Écrivez l'algorithme qui calcule le nombre d'étudiants par option en un seul parcours de la liste
	(vous devrez utiliser trois compteurs distincts).
\end{Exercice}

\chapter{Représentation des données\index{Representation des données@Représentation des données}}
\begin{Exercice}{La course à la case 64 à 4 joueurs}
%---------------------------------------------------
	Commençons par un petit jeu très simple de course avec un dé, dont voici les règles.
	
	\begin{quote}
	\og Ce jeu se joue à 4 joueurs qui doivent parcourir un chemin de 64 cases.
	Ils commencent tous sur la case 1 et jouent à tour de rôle
	(en commençant par le premier joueur).
	À son tour, le joueur lance un dé à 6 faces 
	et avance du nombre de cases indiqué par le dé.
	Le premier joueur à atteindre ou dépasser la case 64 a gagné.
	Seule contrainte, un joueur ne peut pas terminer son tour
	sur une case occupée. 
	Si c'est le cas, il avance jusqu'à la case libre suivante.\fg
	\end{quote}
	
	Voici 3 propositions de représentation de données. 
	On vous demande pour chaque proposition de vérifier, 
	sans écrire l'algorithme, si elle permet la programmation du jeu. 
	On vous conseille vivement de \og{}dessiner\fg{}%
	\footnote{
		Par là, on veut dire : imaginer une situation de jeu
		(positions des joueurs sur le chemin par exemple)
		et voir quelles valeurs doivent avoir les variables
		introduites dans la représentation pour correspondre
		à cette situation de jeu. 
	} les propositions
	pour mieux les comprendre.
	
	\begin{enumerate}
	\item 
		Un tableau de 64 entiers.
		La case $k$ contient $i$ si le joueur $i$ s'y trouve 
		ou $0$ si la case est libre.
		Mais aussi un entier \lda{joueurCourant} donnant
		le numéro du joueur courant.
	\item
		Un tableau de 4 entiers. 
		La case i contient la position du joueur i.
		Mais aussi un entier \lda{joueurCourant} donnant
		le numéro du joueur courant.
	\item
		On combine les deux premières propositions
		(on a donc deux tableaux).
	\end{enumerate}

	Après ces vérifications vous choisirez une des représentations 
	pour écrire la solution (non OO à ce stade) du jeu.
	Pensez à découper votre solution.
	
\end{Exercice}

\begin{Exercice}{La course à la case 64 à n joueurs}
%---------------------------------------------------
	Modifiez l'exercice précédent 
	afin que le jeu puisse se jouer à $n$ joueurs,
	où $n$ est un entier supérieur ou égal à 2, choisi au début du jeu.
\end{Exercice}

\begin{Exercice}{La course à la case 64 à n joueurs - variantes}
%-------------------------------------------------
	Reprenons la course à la case 64 de l'exercice précédent.
	Voici quelques propositions de modification des règles.
	Pour chaque proposition, indiquez si la représentation
	choisie dans l'exercice précédent est toujours valable et pertinente.
	\begin{enumerate}
	\item 
		Si un joueur arrive sur une case occupée, 
		le joueur qui s'y trouvait retourne à la première case.
	\item
		Si un joueur termine sa course sur une case qui est un multiple de 5,
		il rejoue directement.
	\item
		Un joueur rejoue directement s'il termine sa course
		sur les cases 1, 2, 7, 11, 17, 31, 42 ou 53.
	\end{enumerate}	
\end{Exercice}

\begin{Exercice}{Un jeu de poursuite}
%------------------------------------
	Deux joueurs A et B se poursuivent sur un circuit de 50 cases. 
	Au départ, A se trouve sur la case 1 et B est placé sur la case 26.
	C’est A qui commence. 
	Chaque joueur joue à son tour en lançant un dé dont la valeur 
	donne le nombre de cases duquel il doit avancer sur le jeu. 
	Lorsqu’un joueur arrive sur la case 50 et qu’il doit encore avancer, 
	il continue son parcours à partir de la case 1. 
	Le jeu se termine lorsqu’un joueur rattrape ou dépasse l’autre.

	Écrire un algorithme (non OO pour le moment) de simulation de ce jeu
	qui se terminera par l’affichage du vainqueur ainsi que le nombre de
	tours complets parcourus par ce vainqueur. 

	Il est important de bien découper votre algorithme.
	On vous suggère d'écrire les algorithmes suivant :
	\begin{itemize}
		\item 
			un algorithme \lda{initialiser()} qui initialise le jeu
			(placement des joueurs\dots) ;
		\item 
			un algorithme \og{}\lda{~jouerCoup~}\fg{} 
			qui joue pour un joueur et indique s'il a rattrapé l’autre joueur ;
		\item 
			un algorithme \og{}\lda{~joueurSuivant~}\fg{} 
			qui permet de passer au joueur suivant.
	\end{itemize}

	À nouveau, on vous fait plusieurs propositions pour la représentation
	de l'état du jeu.
	On vous demande pour chacune d'elles de vérifier, 
	sans écrire les méthodes de la classe, 
	si elles permettent la programmation du jeu. 
	Après ces vérifications vous choisirez 
	une des représentations pour écrire la classe complète.
	
	\begin{enumerate}
	\item 
		Dans cette proposition, nous avons deux variables.
		\begin{itemize}
		\item 
			\lda{circuit}~: un tableau de 1 à 50 chaines de caractères. 
			Les chaines de caractères représenteront la position des joueurs 
			(au départ, "A" en 1 et "B" en 26, " " dans les autres positions).
		\item
			\lda{joueurCourant}~: un entier donnant la position du joueur courant.
		\end{itemize}
	\item
		Cette proposition introduit une structure \lda{Joueur} et le nombre de tours.
		\begin{itemize}
		\item
			\lda{circuit}: un tableau de 1 à 50 éléments \lda{Joueur}, une structure.
			\begin{algo}
				\Structure{Joueur}{
					\Decl{nom}{string}
						\RComment{\scriptsize Le nom du joueur à cette position ("A", "B" ou " " si la case est vide)}
					\Decl{nbTours}{integer}
						\RComment{\scriptsize Nb de tours qu'a fait le joueur qui est à cette position (0 si case vide)}
				}
			\end{algo}
			Un joueur a fait un tour complet quand il est de nouveau sur sa position de départ
			ou la dépasse.
		\item
			\lda{joueurCourant}: un entier donnant la position du joueur courant.
		\end{itemize}
	\item
		Dans cette proposition, le tableau change de signification.
		\begin{itemize}
		\item
			\lda{circuit}: un tableau de 2 éléments \lda{Joueur}, une structure différente.  
			\begin{algo}
				\Structure{Joueur}{
					\Decl{position}{integer}
						\RComment{\footnotesize Donne la position du joueur sur le circuit (entier entre 1 et 50)}
					\Decl{nbTours}{integer}
						\RComment{\footnotesize Le nombre de tours qu'a fait ce joueur}
				}
			\end{algo}
		\item
			\lda{joueurCourant}: un entier donnant la position du joueur courant.
		\end{itemize}
	\item
		Cette proposition est identique à la précédente sauf sur un point :
		\begin{itemize}
		\item
			On ne retient plus le nombre de tours effectués
			mais simplement le nombre de cases parcourues.
			Par exemple, si un joueur a fait exactement deux tours complets,
			le nombre de cases parcourues sera de 100.
			\begin{algo}
				\Structure{Joueur}{
					\Decl{position}{integer}
						\RComment{\footnotesize Donne la position du joueur sur le circuit (entier entre 1 et 50)}
					\Decl{nbCasesParcourues}{integer}
						\RComment{\footnotesize Nb de cases parcourues par le joueur depuis le départ}
				}
			\end{algo}
		\end{itemize}
	\end{enumerate}	
\end{Exercice}

\begin{Exercice}{Un jeu de poursuite - variante}
%-----------------------------------------------
	Dans cette variante,
	chaque case contient une valeur vrai ou faux
	indiquant si le joueur pourra rejouer.
	Si la case sur laquelle tombe le joueur contient la valeur
	\lda{vrai} il avance encore une fois du même nombre de cases 
	(et de même s’il tombe encore sur \lda{vrai}).
	
	Qu'est-ce que cela change au niveau des données ?
	Modifiez votre solution en conséquence.
	
	Pour adapter le code,
	il faudra adapter les paramètres fournis à l'algorithme d'initialisation
	et à l'algorithme qui joue un coup.
	Nous vous conseillons également de ne pas modifier l'algorithme \lda{jouerCoup} 
	mais d'introduire un nouvel algorithme (par ex. \lda{jouerTour}) 
	qui y fait appel plusieurs fois si nécessaire.
\end{Exercice}

\begin{Exercice}{Le Jeu du Millionnaire}
%---------------------------------------
	Un questionnaire de quinze questions à choix
	multiples de difficulté croissante est soumis à un candidat. Quatre
	possibilités de réponses (dont une seule est correcte) sont proposées à
	chaque fois. Au plus le candidat avance dans les bonnes réponses, au
	plus son gain est grand. S’il répond correctement aux quinze questions,
	il empoche la somme rondelette de 500.000~\texteuro.
	
	Par contre, si le candidat donne une mauvaise
	réponse, il risque de perdre une partie du gain déjà acquis. Cependant,
	certains montants intermédiaires constituent des paliers, c’est-à-dire
	une somme acquise que le candidat est sûr d’empocher, quoiqu’il arrive
	dans la suite du jeu.

	À chaque question, le candidat a donc trois
	possibilités~:
	\begin{itemize}
		\item 
			il donne la réponse correcte : dans ce cas il
			augmente son gain, et peut passer à la question suivante
		\item 
			il ne connait pas la réponse, et choisit de
			s’abstenir : dans ce cas, le jeu s’arrête et le candidat empoche le
			gain acquis à la question précédente
		\item 
			il donne une réponse incorrecte : le jeu
			s’arrête également, mais le candidat ne recevra que le montant du
			dernier palier qu’il a atteint et réussi lors de son parcours. En
			particulier, si le candidat se trompe avant d’avoir atteint le premier
			palier, il ne gagne pas un seul euro !
	\end{itemize}
	
	\begin{minipage}[t][][b]{2.5cm}
	\begin{center}
	\begin{footnotesize}
	\begin{tabular}{|l|l|l|}\hline
	  1 &      25~\texteuro & faux \\\hline
	  2 &      50~\texteuro & faux \\\hline
	  3 &     125~\texteuro & faux \\\hline
	  4 &     250~\texteuro & faux \\\hline
	  5 &     500~\texteuro & vrai \\\hline
	  6 &    1000~\texteuro & faux \\\hline
	  7 &    2000~\texteuro & faux \\\hline
	  8 &    3750~\texteuro & faux \\\hline
	  9 &    7500~\texteuro & faux \\\hline
	 10 &   12500~\texteuro & vrai \\\hline
	 11 &   25000~\texteuro & faux \\\hline
	 12 &   50000~\texteuro & faux \\\hline
	 13 &  100000~\texteuro & vrai \\\hline
	 14 &  250000~\texteuro & faux \\\hline
	 15 &  500000~\texteuro & vrai \\\hline
	\end{tabular}
	\end{footnotesize}
	\end{center}
	\end{minipage}%
	\hfill
	\begin{minipage}[t][][b]{10cm}
	Exemple : Le tableau ci-contre contient les gains associés à chaque 
	question et une indication booléenne mise à
	\lda{vrai} lorsque la question
	constitue un palier. Un concurrent qui se
	trompe à la question 3 ne gagnera rien ; un concurrent qui se trompe à
	la question 6 gagnera 500~\texteuro{} (palier de la question 5) et de même s’il
	se trompe à la question 10 ; un concurrent qui se trompe à la question
	13 gagnera 12500~\texteuro{} (palier de la question 10) ; 
	s'il décide de ne pas répondre à la question 13,
	il garde le montant acquis à la question 12, soit 50000~\texteuro.
	\end{minipage}
	
	Il y aurait de nombreuses façons de coder ce problème; en voici une :

	{\bfseries La structure Question}

	Une question est composée du libellé de la question, des 4 libellés pour
	les réponses et d’une indication de la bonne réponse (un entier de 1 à
	4). Par simplicité on en fait une structure mais on pourrait en faire
	une classe si on voulait par exemple vérifier que la «~bonne réponse~»
	possède une valeur correcte.

	{\bfseries La structure Gain}

	Représente un niveau de gain. Elle contient les champs :
	montant (entier) et palier (un booléen à
	\lda{vrai} si cette somme est
	assurée, \lda{faux} sinon)

	{\bfseries La classe Millionnaire}

	Cette classe code le moteur du jeu. On y retrouve

	\begin{itemize}
		\item 
			questionnaire : un tableau de Question
		\item 
			gains : un tableau de Gain
		\item 
			autres attributs à déterminer (cf. méthodes)
	\end{itemize}
	
	ainsi que les méthodes pour

	\begin{itemize}
		\item 
			initialiser le jeu à partir d’un questionnaire
			et du tableau de gains
		\item 
			connaitre la question en cours
		\item 
			donner la réponse du candidat à la question en
			cours
		\item 
			savoir si le jeu est fini ou pas
		\item 
			arrêter le jeu en repartant avec les gains
		\item 
			les accesseurs nécessaires pour connaitre
			l’état du jeu.
	\end{itemize}
	
	{\bfseries
	Le jeu proprement dit}

	L'algorithme \lda{jeuMillionaireConsole()} reçoit le
	questionnaire et les gains et simule le jeu :

	\begin{itemize}
	\item 
		Il propose les questions au candidat
	\item 
		Il lit ses réponses (chiffre 1 à 4 ou 0 pour
		arrêter) et fait évoluer le jeu en fonction.
	\item 
		lorsque le jeu est terminé, il indique au
		candidat le montant de ses gains.
	\item 
		Attention ! Cet algorithme devrait être le plus
		petit possible. Imaginez que vous devez également coder une version
		graphique. Tout code commun doit se trouver dans la classe
	\lda{Millionnaire~}!
	\end{itemize}
\end{Exercice}

\begin{Exercice}{Chambre avec vue}
%---------------------------------
	Un grand hôtel a décidé d’informatiser sa
	gestion administrative. Il a confié ce travail à la société ESI\_INFO
	dans laquelle vous êtes un informaticien chevronné. On vous a confié la
	tâche particulière de la gestion des réservations pour ses 100
	chambres.
	Pour ce faire, on vous demande d’écrire une
	classe \lda{Hôtel} qui offre
	notamment une méthode qui permet d’enregistrer une réservation.

	Pour représenter l’occupation des chambres un
	jour donné, nous allons utiliser un tableau de 100 entiers. Un 0
	indique que la chambre est libre, une autre valeur (positive) indique
	le numéro du client qui occupe cette chambre ce jour-là.

	Nous utiliserons une Liste de tels tableaux
	pour représenter l’occupation des chambres sur une longue période ; les
	éléments se suivant correspondant à des jours successifs. 

	Nous vous imposons les attributs de la classe,
	à savoir :

	\begin{itemize}
		\item 
			\lda{occupations~}: une Liste de
			tableaux de 100 entiers comme expliqué ci-dessus.
		\item 
			\lda{premierJour~}: donne le
			jour concerné par le premier élément de la liste. Ainsi
			s'il vaut 10/9/2015 cela signifie que le premier
			élément de la liste «~occupations~» renseigne sur l’occupation des
			chambres ce 10/9/2015 ; que le deuxième élément de la liste concerne le
			11/9/2015 et ainsi de suite...
	\end{itemize}
	
	Écrire la méthode suivante

	\begin{algo}
		\MethodSign{effectuerRéservation}{demande\In : DemandeRéservation,
		chambre\Out : integer}{boolean}
	\end{algo}
	
	où la structure de demande de réservation est
	définie ainsi
	
	\begin{algo}
		\Structure{DemandeRéservation}{
			\Decl{numéroClient}{integer}\;
			\Decl{débutRéservation}{Date}\;
			\Decl{nbNuitées}{integer}\;
		}
	\end{algo}

	\begin{itemize}
		\item 
			Le booléen retourné indique si la réservation a pu se faire ou pas
		\item 
			Si elle a pu se faire, le paramètre de sortie
			\lda{chambre} indique la chambre qui a été choisie
		\item 
			Si plusieurs chambres sont libres, on choisit celle avec le plus petit
			numéro
		\item 
			La demande de réservation peut couvrir une période qui n’est pas encore
			reprise dans la liste ; il faudra alors l’agrandir
	\end{itemize}
\end{Exercice}

\begin{Exercice}{L'ensemble}
%---------------------------
	La notion d’ensemble fini est une notion qui vous est déjà 
	familière pour l’avoir rencontrée dans plusieurs cours. Nous rappelons
	certaines de ses propriétés et opérations. 
			
	Étant donnés deux ensembles
	finis \textbf{S} et \textbf{T} ainsi qu’un élément \textbf{x} :

	\begin{itemize}
	\item 
		\textbf{x} {${\in}$} \textbf{S} signifie que l’élément \textbf{x}
		est un élément de l’ensemble \textbf{S}.
	\item 
		L’ensemble vide, noté \textbf{${\emptyset}$} 
		est l’ensemble qui n’a pas d’élément 
		(\textbf{x} {${\in}$} \textbf{${\emptyset}$} 
		est faux quel que soit \textbf{x} ).
	\item 
		L’ordre des éléments dans un ensemble n’a
		aucune signification, l’ensemble \{1,2\} est
		identique à \{2,1\}.
	\item 
		Un élément \textbf{x} ne peut
		pas être plus d’une fois élément d’un même ensemble 
		(pas de répétition).
	\item 
		L’union \textbf{S ${\cup}$ T} 
		est l’ensemble contenant les éléments qui sont dans 
		\textbf{S} ou (non exclusif) dans \textbf{T}.
	\item 
		L’intersection \textbf{S ${\cap}$ T} 
		est l’ensemble des éléments qui sont à la fois 
		dans \textbf{S} et dans \textbf{T}.
	\item 
		La différence \textbf{S {\textbackslash} T} 
		est l’ensemble des éléments qui sont 
		dans \textbf{S} mais pas dans \textbf{T}.
	\end{itemize}
	
	Créer la classe \lda{Ensemble}
	décrite ci-dessous
	(où E est le type des éléments de l'ensemble).
	
	\begin{algo}
		\Class{Ensemble de E}{		
			\Public{
				\ConstrSign{Ensemble de E}{} 
				\RComment{construit un ensemble vide}
				\MethodSign{ajouter}{élt : E}{}
				\RComment{ajoute l'élément à l'ensemble}
				\MethodSign{enlever}{élt : E}{})
				\RComment{enlève un élément de l'ensemble}
				\MethodSign{contient}{élt : E}{boolean}
				\RComment{dit si l'élément est présent}
				\MethodSign{estVide}{}{boolean}
				\RComment{dit si l'ensemble est vide}
				\MethodSign{taille}{}{integer}
				\RComment{donne la taille de l'ensemble}
				\MethodSign{union}{autreEnsemble : Ensemble de E}{Ensemble de E}\;
				\MethodSign{intersection}{autreEnsemble : Ensemble de E}{Ensemble de E}\;
				\MethodSign{moins}{autreEnsemble : Ensemble de E}{Ensemble de E}\;
				\MethodSign{éléments}{}{List of E}
				\RComment{conversion en liste}
			}
		}
	\end{algo}
	Quelques remarques :
	\begin{itemize}
		\item 
			La méthode d'ajout (resp. de suppression) n'a
			pas d'effet si l'élément est déjà
			(resp. n'est pas) dans l'ensemble.
		\item 
			Les méthodes \lda{union()}, 
			\lda{intersection()} et 
			\lda{moins()} retournent un troisième ensemble, 
			résultat des 2 premiers sans toucher
			à ces 2 ensembles. On aurait pu envisager des méthodes modifiant
			l'ensemble sur lequel on les appelle.
		\item 
			La méthode \lda{éléments()}
			est nécessaire si on veut parcourir les éléments de
			l'ensemble (par exemple pour les afficher).
	\end{itemize}	
\end{Exercice}

\begin{Exercice}{La course à la case 64 en version OO}
%-----------------------------------------------
	Reprenez la solution que vous avez écrite pour l'exercice 2
	(La course à la case 64 à n joueurs)
	et voyez comment le transformer pour en faire une version OO.	
\end{Exercice}

\begin{Exercice}{Un jeu de poursuite en version OO}
%-----------------------------------------------
	Reprenez la solution que vous avez écrite pour l'exercice 5
	(Un jeu de poursuite - variante)
	et voyez comment le transformer pour en faire une version OO.
\end{Exercice}

\begin{Exercice}{Les congés}
%---------------------------
	Les périodes de congés des différents employés d’une firme sont reprises
	dans un tableau booléen \textbf{Congés} bidimensionnel à \textit{n}
	lignes et 366 colonnes. Chaque ligne du tableau correspond à un employé
	et chaque colonne à un jour de l’année. Une case est mise
	à \textbf{vrai} si l’employé correspondant est en congé le jour
	correspondant. La firme en question est opérationnelle 7 jours sur 7,
	on n’y fait donc pas de distinction entre jours ouvrables, week-end et
	jours fériés.

	Ce tableau permet de visualiser l’ensemble des congés des travailleurs,
	et d’accorder ou non une demande de congé, suivant les règles suivantes :
	\begin{enumerate}
		\item 
			une période de congé ne peut excéder 15 jours ;
		\item 
			un employé a droit à maximum 40 jours de congé par an ;
		\item 
			à tout moment, 50\% des employés doivent être présents dans la firme.
	\end{enumerate}
	
	Écrire un algorithme qui détermine si cette demande peut être accordée
	ou non à un employé dont on connait le nom, ainsi que les dates de
	début et de fin d’une demande de congé (objets de la classe Date). Dans
	l’affirmative, le tableau \textbf{Congés} sera mis à jour.

	Pour établir la correspondance entre ce tableau et les noms des
	employés, vous avez à votre disposition un tableau \textbf{Personnel}
	de chaines. L’emplacement du nom d’un employé dans ce tableau
	correspond à l’indice ligne du tableau \textbf{Congés}.

	Il est permis d’utiliser pour résoudre cet exercice la méthode suivante
	de la classe Date, sans devoir détailler son code :
	
	\begin{algo}
		\MethodSign{numéroJour}{}{integer}
		\RComment{la position du jour dans l’année (entre 1 et 366)}
	\end{algo}
\end{Exercice}

\begin{Exercice}{Casino}
%-----------------------
	Pour cet exercice,
	on vous demande un petit programme qui simule un jeu de roulette
	très simplifié dans un casino.
	
	Dans ce jeu simplifié, vous pourrez miser une certaine somme 
	et gagner ou perdre de l'argent (telle est la fortune, au casino !). 
	Quand vous n'avez plus d'argent, vous avez perdu.

	\textbf{Notre règle du jeu}

	Bon, la roulette, c'est très sympathique comme jeu, 
	mais un peu trop compliqué pour un exercice de première année.
	Alors, on va simplifier les règles et je vous présente tout de suite 
	ce que l'on obtient :
	\begin{itemize}
	\item
		Le joueur mise sur un numéro compris entre 0 et 49 (50 numéros en tout). 
		En choisissant son numéro, il y dépose la somme qu'il souhaite miser.
	\item
		La roulette est constituée de 50 cases allant naturellement de 0 à 49. 
		Les numéros pairs sont de couleur noire, 
		les numéros impairs sont de couleur rouge. 
		Le croupier lance la roulette, 
		lâche la bille et quand la roulette s'arrête, 
		relève le numéro de la case dans laquelle la bille s'est arrêtée. 
		Dans notre programme, nous ne reprendrons pas tous ces détails 
		« matériels » mais ces explications sont aussi à l'intention 
		de ceux qui ont eu la chance d'éviter les salles de casino jusqu'ici. 
		Le numéro sur lequel s'est arrêtée la bille est, naturellement, 
		le numéro gagnant.
	\item
		Si le numéro gagnant est celui sur lequel le joueur a misé 
		(probabilité de 1/50, plutôt faible), 
		le croupier lui remet 3 fois la somme misée.
	\item
		Sinon, le croupier regarde si le numéro misé par le joueur 
		est de la même couleur que le numéro gagnant 
		(s'ils sont tous les deux pairs ou tous les deux impairs). 
		Si c'est le cas, le croupier lui remet 50\% de la somme misée. 
		Si ce n'est pas le cas, le joueur perd sa mise.
	\end{itemize}
	
	Dans les deux scénarios gagnants vus ci-dessus 
	(le numéro misé et le numéro gagnant sont identiques ou ont la même couleur), 
	le croupier remet au joueur la somme initialement misée avant d'y ajouter ses gains. 
	Cela veut dire que, dans ces deux scénarios, le joueur récupère de l'argent. 
	Il n'y a que dans le troisième cas qu'il perd la somme misée.
	
	Comme vous pouvez le constater,
	on ne vous fait pas de proposition pour la représentation des données.
	À vous de jouer !
\end{Exercice}

\begin{Exercice}{Mots croisés}
%-----------------------------
	Voici une grille de mots croisés.
	(on ne s'intéresse pas ici aux définitions).
	Écrire une classe \lda{Grille} offrant les méthodes
	suivantes :
	\begin{itemize}
		\item 
			placer une lettre à un endroit de la grille 
			(une case non noire bien sûr) ;
		\item 
			donner le nombre de cases noires sur la grille ;
		\item 
			donner le nombre total de mots (plus d'une lettre) de la grille 
			(donc y compris ceux que le
			joueur n’a pas encore complétés) ; 
		\item 
			donner le nombre de mots déjà complétés par le joueur.
	\end{itemize}

	\medskip
	\begin{minipage}[t][][t]{6cm}
	Exemple : dans la grille ci-contre, le nombre de cases noires est 14, le
	nombre total de mots de la grille est 37 (19 horizontaux et 18
	verticaux) et le nombre de mots déjà complétés par le joueur est 6.
	\end{minipage}
	~
	\begin{minipage}[t][][b]{8cm}	
	\begin{footnotesize}
	\begin{center}
	\begin{tabular}{|*{10}{>{\centering\arraybackslash}m{0.30cm}|}}
	\hline
	~ & ~ & A & ~ & ~ & ~ & \cellcolor{gray!50} & ~ & ~ & ~ \\\hline
	~ & ~ & L & ~ & \cellcolor{gray!50} & ~ & ~ & ~ & ~ & ~ \\\hline
	L & O & G & I & Q & U & E & \cellcolor{gray!50} & ~ & ~ \\\hline
	~ & ~ & O & \cellcolor{gray!50} & ~ & ~ & ~ & \cellcolor{gray!50} & ~ & ~ \\\hline
	\cellcolor{gray!50} & ~ & R & ~ & \cellcolor{gray!50} & ~ & \cellcolor{gray!50} & ~ & ~ & ~ \\\hline
	E & S & I & \cellcolor{gray!50} & O & ~ & H & ~ & \cellcolor{gray!50} & ~ \\\hline
	~ & \cellcolor{gray!50} & T & A & B & L & E & A & U & \cellcolor{gray!50} \\\hline
	~ & ~ & H & \cellcolor{gray!50} & J & ~ & B & ~ & ~ & ~ \\\hline
	~ & ~ & M & ~ & E & ~ & \cellcolor{gray!50} & ~ & ~ & ~ \\\hline
	~ & ~ & E & ~ & T & ~ & ~ & ~ & ~ & ~ \\\hline
	\end{tabular}
	\end{center}
	\end{footnotesize}
	\end{minipage}
	
	%Un tableau \lda{grille} à 10 lignes et 10 colonnes contient les données
	%relatives à un jeu de mots croisés simulé sur ordinateur. Chaque
	%élément de ce tableau est une structure \lda{Case},
	%contenant les deux champs :

	%\begin{itemize}
		%\item 
			%\lda{noir} : variable booléenne affectée à
			%\lda{vrai} si la case correspondant de la grille est une
			%case noire;
		%\item 
			%\lda{lettre} : contient soit le caractère inscrit par le
			%joueur dans une case, soit le caractère «~espace~» (‘ ‘) si la case est
			%encore blanche; lorsque \lda{noir} est vrai, le contenu
			%de \lda{lettre} est indéterminé et ne peut donc être
			%utilisé. 
	%\end{itemize}
		
\end{Exercice}

\begin{Exercice}{Puissance 4}
%----------------------------
	Le jeu de puissance 4 se déroule dans un tableau vertical comportant 6
	rangées et 7 colonnes dans lequel deux joueurs introduisent tour à tour
	des jetons (rouges pour l’un, jaunes pour l’autre). Avec l’aide de la
	gravité, les jetons tombent toujours le plus bas possible dans les
	colonnes où on les place. Le jeu s’achève lorsqu’un des joueurs a
	réussi à aligner 4 de ses jetons horizontalement, verticalement ou en
	oblique, ou lorsque les deux joueurs ont disposé chacun leur 21 jetons
	sans réaliser d’alignement (match nul).

	\begin{minipage}[t][][b]{4cm}
	\includegraphics[width=0.8\textwidth]{image/puissance4}
	\end{minipage}
	\begin{minipage}[t][][b]{10cm}
	N.B. : sur ce dessin noir et
	blanc, les jetons rouges apparaissent en noir, les jetons jaunes en
	gris et les cases blanches désignent l'absence de
	jetons. Cet exemple montre une situation du jeu où le joueur «~jaune~»
	est gagnant. En introduisant un jeton dans la
	4\textsuperscript{e} colonne,
	il a réalisé un alignement de 4 jetons en oblique.
	\end{minipage}
	
	On demande d’implémenter une classe Puissance4 qui permette de contrôler
	l’état des différentes phases du jeu. Déterminez les attributs de cette
	classe et décrivez-les brièvement de manière à justifier votre choix.
	Dotez ensuite la classe des méthodes permettant de :

	\begin{itemize}
		\item 
			savoir si la grille est pleine
		\item 
			mettre la grille à jour lorsque le joueur n (1 ou 2) joue dans la
			colonne j (entre 1 et 7). Cette méthode renverra la valeur booléenne
			faux si la colonne en question est déjà pleine
		\item 
			vérifier si le joueur qui vient de jouer dans la colonne j a gagné la
			partie
	\end{itemize}
	
	N.B. : pour la structure qui contiendra le contenu du tableau de jetons,
	on adoptera la convention suivante : 0 pour l’absence de jeton, 1
	représentera un jeton du 1\textsuperscript{er} joueur, et 2 un jeton du
	2\textsuperscript{e} joueur (on peut donc faire abstraction de la
	couleur du jeton dans ce problème).
	
\end{Exercice}

\begin{Exercice}{Mastermind}
%---------------------------
	Revenons sur le jeu Mastermind déjà vu en DEV1.
	Dans ce jeu, un joueur A doit trouver une combinaison de
	\lda{k} pions de couleur, choisie et tenue secrète
	par un autre joueur B. Cette combinaison peut contenir éventuellement
	des pions de même couleur. À chaque proposition du joueur A, le joueur
	B indique le nombre de pions de la proposition qui sont corrects et
	bien placés et le nombre de pions corrects mais mal placés. 

	\textbf{Exemple}

	Utilisons des lettres pour représenter les couleurs.
	
	\begin{minipage}{5cm}
		\begin{center}
		Combinaison secrète
		
		\begin{tabular}{|*{5}{>{\centering\arraybackslash}m{0.35cm}|}}
			\hline
			R & R & V & B & J \\
			\hline
		\end{tabular}
		\end{center}	
	\end{minipage}
	\
	\begin{minipage}{5cm}
		\begin{center}
		Proposition du joueur
	
		\begin{tabular}{|*{5}{>{\centering\arraybackslash}m{0.35cm}|}}
			\hline
			R & V & B & B & V \\
			\hline
		\end{tabular}
		\end{center}
	\end{minipage}
	
	Il sera indiqué au joueur qu'il a :
	\begin{itemize}
	\item 2 pions bien placés : le R en 1\iere{} position et le
	second B en 4\ieme{} position ;
	\item 1 pion mal placé : un des deux V (ils ne peuvent compter tous les deux).
	\end{itemize}
	
	\medskip
	Supposons une énumération \lda{Couleur}
	(cf. la description d'une énumération en annexe) 
	avec toutes les couleurs possibles de pion.

	\begin{enumerate}[label=\alph*)]
		\item
			Écrire une classe «\lda{~Combinaison~}» pour
			représenter une combinaison de \lda{k} pions. Elle
			possède une méthode pour générer une combinaison aléatoire (que vous ne
			devez pas écrire) et une méthode pour comparer une combinaison à la
			combinaison secrète (que vous devez écrire)
		\item
			Écrire ensuite une classe «\lda{~MasterMind~}» qui
			représente le jeu et permet d’y jouer. La taille de la combinaison et
			le nombre d’essais permis seront des paramètres du constructeur.
	\end{enumerate}
\end{Exercice}

