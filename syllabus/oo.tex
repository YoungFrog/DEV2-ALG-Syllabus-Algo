%========================
\chapter{L'orienté objet}
%=========================

	\marginicon{objectif}
	Le cours de Java vous a présenté la programmation orienté objet.
	Dans ce chapitre, nous allons rapidement revoir ce sujet
	et présenter comment nous allons l'utiliser dans ce cours.
	Nous nous contenterons de parler d'\textit{encapsulation}. 
	Les autres piliers de l'orienté objet 
	(\textit{héritage} et \textit{polymorphisme}) 
	ne seront pas vus cette année.

%===================
\section{Motivation}
%====================

	Au cours de Java,
	vous avez vu que l'orienté objet permet de structurer une
	application en regroupant dans un même \emph{objet}
	des données et le code qui va manipuler ces données.
	
	Une autre façon de voir l'orienté objet
	est de constater qu'une classe permet de définir 
	un nouveau \emph{type de données}.
	La notion de \emph{structure} permet déjà cela mais de façon limitée
	car elle ne reprend que des données et pas du code.
	Avec l'orienté objet, 
	on dispose de méthodes définissant ce qu'on peut faire avec des données
	(les objets) de ce type.
	C'est ainsi que nous l'utiliserons pour définir les listes 
	dans un prochain chapitre.

	
%=======================================
\section{Illustration~: une durée}
%=======================================

	Voyons tout cela au travers d'un exemple complet.
	Il est parfois utile d'avoir à sa disposition un type
	de données permettant de représenter une durée.	
	Utiliser plusieurs entiers (un pour les heures, un autre pour les minutes,
	un autre encore pour les secondes) n'est pas pratique.
	Utiliser une structure est déjà mieux mais offre moins d'avantage
	que l'orienté objet.	
	Voyons comment définir ce nouveau type de données en orienté objet.
	
	\subsection{Ce que l’on veut vraiment}
	
		Avant tout, il faut bien préciser ce que l’on veut décrire
		et bien faire la distinction entre un \emph{moment} et une \emph{durée}.
		L’«~heure~» est un concept multifacettes. 
		Parle-t-on de l’heure comme moment dans la journée 
		ou de l’heure comme représentant une durée ? 
		Dans le premier cas, elle ne peut dépasser 24h 
		et la différence entre 2 heures n’a pas de sens 
		(ou plus précisément n’est pas une heure, mais une durée !).
		Ce que nous nous proposons de créer ici est une durée,
		correspondand au deuxième cas.
		Et pour être plus précis encore,
		nous allons nous limiter à une précision à la seconde près,
		pas plus%
		\footnote{%
			Ajouter plus de précision ne serait pas plus compliqué à faire.%
		}.
	
	\subsection{Le comportement (les méthodes)}
	
		La première question à se poser est celle des services qu’on veut
		fournir, c’est-à-dire des méthodes publiques de la classe. On doit
		pouvoir \textit{construire} une durée. On doit pouvoir connaitre le
		nombre de jours, d’heures, minutes ou secondes correspondant à une durée. On doit
		pouvoir effectuer des calculs avec des durées (addition, soustraction).
		Enfin, on doit pouvoir comparer des durées. Arrêtons-nous là, mais en
		pratique, on pourrait trouver encore bon nombre d’autres méthodes qu’il
		serait intéressant de fournir. 
		
		Voici comment nous allons noter tout cela au cours d'algorithmique.
		
		\begin{LDA}
			\Class{Durée}
				%\Private
					%\LComment rien encore
				\Public
					\ConstrSign{Durée}{secondes~: entier}
					\ConstrSign{Durée}{heure, minute, seconde~: entiers}
					\Empty
					\MethodSign{getJour}{}{entier}
					\RComment nb de jours dans une durée
					\MethodSign{getHeure}{}{entier}
					\RComment entier entre 0 et 23 inclus
					\MethodSign{getMinute}{}{entier}
					\RComment entier entre 0 et 59 inclus
					\MethodSign{getSeconde}{}{entier}
					\RComment entier entre 0 et 59 inclus
					\Empty
					\MethodSign{getTotalHeures}{}{entier}
					\RComment Le nombre total d’heures
					\MethodSign{getTotalMinutes}{}{entier}
					\RComment Le nombre total de minutes
					\MethodSign{getTotalSecondes}{}{entier}
					\RComment Le nombre total de secondes
					\Empty
					\MethodSign{ajouter}{autreDurée~: Durée}{}
					\MethodSign{différence}{autreDurée~: Durée}{Durée}
					%\MethodSign{égale}{autreDurée~: Durée}{booléen}
					\MethodSign{plusPetit}{autreDurée~: Durée}{booléen}
			\EndClass
		\end{LDA}
		
		\marginicon{attention}
		\textbf{Quelques remarques}
		\begin{itemize}
			\item
				On a deux constructeurs, ce qui offre plus de souplesse pour initialiser
				un objet. Ceci est un exemple supplémentaire du concept de
				«\textbf{~surcharge~}».
			\item
				Faisons bien la distinction entre les méthodes
				\lda{getXXX()} et \lda{getTotalXXX()}. Par
				exemple, la méthode \lda{getMinute()} retourne la valeur
				de la composante «~minutes~» dans une représentation HMS tandis que la
				méthode \lda{getTotalMinutes()} retourne le nombre total
				de minutes entières pour cette durée. Ex~: pour 1h23’12’’,
				\lda{getMinute()} retourne 23 et
				\lda{getTotalMinutes()} retourne 83. 
				Idem avec les heures et les secondes.
			\item 
				Les méthodes \lda{getTotalXXX()} retournent le nombre
				(toujours entier) de XXX contenus dans la durée. Exemple, avec la durée
				0h23’52'’, \lda{getTotalMinutes()}
				retourne 23 et pas 24 (autrement dit, il n’y a pas d’arrondi vers le
				haut).
			\item 
				Il n’y a pas de \textit{mutateur }(\lda{setXXX()}). Ce qui
				signifie qu’on ne peut pas changer directement la valeur de l’objet
				après son initialisation. On aurait pu en définir mais nous
				n'avons pas jugé utile de le faire dans ce cas
				précis.
			\item 
				La méthode \lda{ajouter()} ne retourne rien. En effet,
				elle ajoute la durée à l’objet sur lequel est appelée la méthode. C’est
				un choix ; on aurait aussi pu dire que la méthode ne modifie pas
				l’objet mais en retourne un autre qui représente la somme. Dans ce cas,
				on l’aurait plutôt appelée «\lda{~plus( )}~».
			\item 
				La méthode \lda{différence()}, elle, renvoie toujours une
				durée (positive).
			\item 
				Nous ne définissons pas de méthode d'affichage
				similaire au \lda{toString()} qu'on retrouve en Java.
				L'affichage correct de l'information ne fait pas partie
				des préoccupations de ce cours.
				On supposera que "\lda{\K{afficher} objet}"
				affiche correctement les données associées à l'objet.
		\end{itemize}
	
	\subsection{La représentation de l'état (les attributs)}
	
		La question suivante est~: «~Comment représenter une durée en interne ?
		». Plusieurs possibilités existent. Par exemple~:	
		\begin{itemize}
			\item 
				via le nombre d’heures, de minutes et de secondes
			\item 
				via le nombre total de secondes
			\item 
				via une chaine, par exemple au format «~HH~:MM~:SS~» où HH pourrait
				éventuellement excéder 23.
		\end{itemize}
		
		Le premier choix semble le plus évident mais réfléchissons-y de plus
		près. D’une part, pourquoi se limiter aux heures. On pourrait
		introduire un champ ‘\lda{jour}’ (après tout on a bien
		une méthode \lda{getJour()}). 
		
		Quel critère doit vraiment nous permettre de décider ? Il faut une
		représentation qui soit suffisante (tout est représenté) et qui
		permette d’écrire des méthodes lisibles et si possible efficaces
		(c'est-à-dire où le calcul est rapide). Selon ces
		critères, la deuxième représentation est de loin la meilleure. 
		
		Voilà comment nous indiquons les attributs d'une classe.
		
		\begin{LDA}
			\Class{Durée}
				\Private
					\Decl{totalSecondes}{entier}
				\Public
					\LComment idem
			\EndClass
		\end{LDA}
	
	\subsection{L'implémentation}
	
		On est à présent prêt pour écrire le code des méthodes. 
		Pour une meilleure lisibilité,
		nous gardons les signatures des méthodes dans la classe
		et nous détaillons leur contenu en dehors.
		Ce qui donne :
		
		\begin{LDA}
			\Class{Durée}
				\Private
					\Decl{totalSecondes}{entier}
				\Public
					\ConstrSign{Durée}{secondes~: entier}
					\ConstrSign{Durée}{heure, minute, seconde~: entiers}
					\Empty
					\MethodSign{getJour}{}{entier}
					\RComment nb de jours dans une durée
					\MethodSign{getHeure}{}{entier}
					\RComment entier entre 0 et 23 inclus
					\MethodSign{getMinute}{}{entier}
					\RComment entier entre 0 et 59 inclus
					\MethodSign{getSeconde}{}{entier}
					\RComment entier entre 0 et 59 inclus
					\Empty
					\MethodSign{getTotalHeures}{}{entier}
					\RComment Le nombre total d’heures
					\MethodSign{getTotalMinutes}{}{entier}
					\RComment Le nombre total de minutes
					\MethodSign{getTotalSecondes}{}{entier}
					\RComment Le nombre total de secondes
					\Empty
					\MethodSign{ajouter}{autreDurée~: Durée}{}
					\MethodSign{différence}{autreDurée~: Durée}{Durée}
					%\MethodSign{égale}{autreDurée~: Durée}{booléen}
					\MethodSign{plusPetit}{autreDurée~: Durée}{booléen}
			\EndClass
		\end{LDA}

		\begin{LDA}
			\Constr{Durée}{secondes~: entier}
				\If{secondes < 0}
					\Stmt \K{erreur} "paramètre négatif"
				\EndIf
				\Let totalSecondes \Gets secondes
			\EndConstr
		\Empty
			\Constr{Durée}{heure, minute, seconde~: entiers}
				\If{heure < 0 OU minute < 0 OU seconde < 0}
					\Stmt \K{erreur} "un des paramètres est négatif"
				\EndIf
				\Let totalSecondes \Gets 3600*heure + 60*minute + seconde
			\EndConstr
		\Empty
			\LComment Retourne le nombre de jours dans une 
			représentation JJ/HH:MM:SS
			\Method{getJour}{}{entier}
				\Return totalSecondes DIV (3600*24)
			\EndMethod
		\Empty
			\LComment Retourne le nombre d'heures dans une 
			représentation JJ/HH:MM:SS
			\Method{getHeure}{}{entier}
				\LComment On doit enlever les jours éventuels
				\Return (totalSecondes DIV 3600) MOD 24
			\EndMethod
		\Empty
			\LComment Retourne le nombre de minutes dans une 
			représentation JJ/HH:MM:SS
			\Method{getMinute}{}{entier}
				\LComment On doit enlever les heures éventuelles
				\Return (totalSecondes DIV 60) MOD 60
			\EndMethod
		\Empty
			\LComment Retourne le nombre de secondes dans une 
			représentation JJ/HH:MM:SS
			\Method{getSeconde}{}{entier}
				\LComment On doit enlever les minutes éventuelles
				\Return totalSecondes  MOD 60
			\EndMethod
		\Empty
			\LComment Retourne le nombre entier d’heures complètes
			\Method{getTotalHeures}{}{entier}
				\Return totalSecondes DIV 3600
			\EndMethod
		\Empty
			\LComment Retourne le nombre entier de minutes complètes
			\Method{getTotalMinutes}{}{entier}
				\Return totalSecondes DIV 60
			\EndMethod
		\Empty
			\LComment Retourne le nombre entier de secondes complètes
			\Method{getTotalSecondes}{}{entier}
				\Return totalSecondes
			\EndMethod
		\Empty
			\Method{ajouter}{autreDurée~: Durée}{}
				\Let totalSecondes \Gets totalSecondes + autreDurée.totalSecondes
			\EndMethod
		\Empty
			\Method{différence}{autreDurée~: Durée}{Durée}
				\Return \K{nouvelle} Durée(valeurAbsolue(totalSecondes - autreDurée.totalSecondes))
			\EndMethod
		%\Empty
			%\Method{égale}{autreDurée~: Durée}{booléen}
				%\Return totalSecondes = autreDurée.totalSecondes
			%\EndMethod
		\Empty
			\Method{plusPetit}{autreDurée~: Durée}{booléen}
				\Return totalSecondes < autreDurée.totalSecondes
			\EndMethod
		\end{LDA}

%=====================================
\section{Utiliser}
%=====================================

	Pour utiliser le nouveau type de donnée créé,
	il faut l'instancier, c'est-à-dire créer un nouvel objet de ce type.
	Nous allons reprendre une notation très proche de Java.
	
	Illustrons cela au travers d'un petit algorithme
	qui calcule la différence entre deux durées.
	
	\begin{LDA}
		\Algo{diffDurée}{}{}
			\Decl{durée1, durée2}{Durée}	\RComment Les variables sont déclarées/créées
			\Let durée1 \Gets \K{nouveau} Durée(3, 4, 49)	\RComment Les objets sont créés
			\Let durée2 \Gets \K{nouveau} Durée(3, 24, 37)	\RComment Les objets sont créés
			\Write durée2.différence(durée1)
		\EndAlgo
	\end{LDA}
	
%=====================================
\section{Quelques éléments de syntaxe}
%=====================================

	Clarifions certaines notations liées aux objets.

	\begin{itemize}
		\item
			On peut directement afficher un objet. 
			Cela affiche son état, c'est-à-dire les valeurs de ses attributs.

			\begin{LDA}
				\Decl{rendezVous}{Durée}
				\Let rendezVous \Gets \K{nouveau} Durée(14, 23, 56)
				\Write rendezVous 
				\RComment affichera 14, 23 et 56 dans un format lisible quelconque
			\end{LDA}
		\item
			De même, on peut directement lire un objet,
			ce qui a pour effet de créer un objet avec un état
			correspondant aux valeurs lues pour ses attributs.

			\begin{LDA}
				\Decl {rendezVous}{Durée}
				\Read rendezVous
			\end{LDA}
		\item 
			Le signe «~=~» peut être utilisé pour comparer deux objets.
			Ils seront considérés comme égaux s'ils sont dans le même état, 
			c'est-à-dire que leurs attributs ont la même valeur.
		\item
			Lorsqu'on déclare un objet, il n'est pas encore créé.
			On peut utiliser la valeur spéciale «~rien~»
			pour indiquer ou tester qu'un objet n'est pas encore créé.
			
			\begin{LDA}
				\Decl{parcours}{Durée}								\RComment parcours = rien
				\Let parcours \Gets \K{nouveau} Durée( 14, 23, 56 )	\RComment parcours ${\neq}$ rien
				\If{parcours $\neq$ rien}
					\Let parcours \Gets rien						\RComment parcours = rien
				\EndIf
			\end{LDA}
	\end{itemize}
