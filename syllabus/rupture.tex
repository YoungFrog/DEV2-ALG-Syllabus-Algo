\definecolor{colnivo}{RGB}{153, 102, 0}
\definecolor{colnivi}{RGB}{255, 153, 0}
\definecolor{colnivii}{RGB}{255, 102, 153}
\definecolor{colcalc}{RGB}{0, 102, 255}
\newcommand{\nivo}[1]{ {\color{colnivo}#1} }
\newcommand{\nivi}[1]{ {\color{colnivi}#1} }
\newcommand{\nivii}[1]{ {\color{colnivii}#1} }
\newcommand{\nivc}[1]{ {\color{colcalc}#1} }

%===================================
\chapter{Les traitements de rupture}
\label{chap:rupture}
%===================================

	Dans ce chapitre, nous allons étudier une classe de problèmes 
	qui peuvent tous se résoudre avec un même type d'algorithme :
	l'algorithme de rupture. 
	
	Considérons un problème comme celui-ci :
	\begin{quotation}
		\slshape
		\og{}Soit une liste d'étudiants, 
		où un étudiant est représenté par un objet reprenant son nom,
		son numéro, son option et son année.
		Écrire un algorithme qui compte le nombre d'étudiants dans chaque section
		et, plus précisément, dans chaque année de chaque section.\fg{}
	\end{quotation}
	
	Nous verrons que l'algorithme de rupture sera adapté à la résolution de
        ce problème lorsque la liste est triée d'une certaine manière.
	C'est pourquoi nous allons commencer par parler du \emph{classement complexe}
	des éléments.
	
	À la fin du chapitre vous
	devrez être capable de :	
	\begin{itemize}
		\item 
			Détecter qu'on se trouve bien face à un problème qui
			peut entrer dans le cadre d'un algorithme de rupture
			et identifier si le tri des éléments est adéquat.
		\item 
			Adapter le squelette général de l'algorithme de rupture
			au problème donné.
	\end{itemize}

%===============================
\section{Le classement complexe}
%===============================

\subsection*{Introduction}

	Dans le chapitre sur les tris du cours d'algorithmique I (DEV$_1$), 
	vous avez abordé naturellement la notion du classement des données. 
	Néanmoins, les données étaient «~simples~» : 
	nombres ou chaines, pour lesquelles la relation d’ordre est évidente. 
	Les algorithmes mis en œuvre peuvent facilement s’adapter pour d’autres types, 
	par exemple des objets \lda{Date}, où l’opérateur de comparaison est remplacé par la méthode
	«~\lda{estAntérieure()}~».
	
	Mais, plus généralement, les données composées de plusieurs
	éléments -- comme les attributs d'un objet -- 
	ne possèdent pas de relation d’ordre naturelle. 
	C'est le cas, par exemple, des points d’un espace à deux ou trois dimensions
	ou encore des informations figurant sur une carte d’identité. 
	Si on veut ordonner une série de telles données, 
	il faudra choisir un premier critère de classement 
	(par exemple le nom ou la date de naissance) 
	et en cas d’égalité sur le premier critère 
	(deux personnes peuvent avoir un même nom ou être nées le même jour), 
	il faudra départager sur un second critère, 
	et ainsi de suite.
	
	Ces critères de classement sont bien entendu arbitraires, 
	et dépendent de l’information qu’on veut retirer de l’ensemble des données. 
	Notons aussi que l’ordre de classement peut être, pour chaque critère, 
	croissant ou décroissant.

\subsection*{Exemple de classement simple}

	Prenons l’exemple d’un objet \texttt{Etudiant}, 
	contenant les attributs \texttt{matricule}, \texttt{nom}, \texttt{prénom}, 
	\texttt{dateNaissance} et \texttt{option} (G, I ou R). 
	Pour l’exemple, considérons une liste de 6 étudiants :
	
	\begin{center}
	\small\sffamily
	\begin{tabular}{cllrc}
		matricule 	& nom 		& prénom 	& dateNaissance & option \\
		\hline 
		29845     	& Durant 	& Kevin 	& 20/01/94 		& R\\
		30125 		& Dupont	& Fabrice 	& 13/06/94 		& G\\
		30351 		& Simon 	& André 	& 18/11/94 		& G\\
		30597 		& Dupont 	& Charles 	& 9/07/94 		& G\\
		31857 		& Guilmant  & Léon 		& 17/03/96 		& R\\
		31886 		& Durant  	& Sam 		& 30/05/94 		& I\\
		\hline 
	\end{tabular}
	\end{center}
	
	Cette liste est classée sur le numéro de matricule. C’est un classement
	simple réalisé sur un seul champ des données. Le numéro de matricule
	étant dans ce cas-ci un \textbf{\textcolor{black}{identifiant}} des
	données, le problème de devoir départager ne se pose pas.

\subsection*{Exemple de classement double}

	Si nous désirons à présent classer sur l’ordre alphabétique des noms, il
	faut décider de départager, en cas de noms identiques, sur un autre
	champ, de façon naturelle sur celui des prénoms. Ceci donnerait le
	classement double suivant, en \textbf{majeur} sur le nom et en
	\textbf{mineur} sur le prénom :
	
	\begin{center}
	\small\sffamily
	\begin{tabular}{cllrc}
		matricule 	& nom 		& prénom 	& dateNaissance & option \\
		\hline 
		30597 		& Dupont 	& Charles 	& 9/07/94 		& G\\
		30125 		& Dupont	& Fabrice 	& 13/06/94 		& G\\
		29845     	& Durant 	& Kevin 	& 20/01/94 		& R\\
		31886 		& Durant  	& Sam 		& 30/05/94 		& I\\
		31857 		& Guilmant  & Léon 		& 17/03/96 		& R\\
		30351 		& Simon 	& André 	& 18/11/94 		& G\\
		\hline 
	\end{tabular}
	\end{center}
	
\subsection*{Exemple de classement triple}

	Supposons enfin que nous voulions grouper les étudiants par sections,
	nous devons alors classer prioritairement sur l’option, départager sur
	les noms et ensuite sur les prénoms. C’est alors un classement triple :
	en \textbf{majeur} sur l’option, en \textbf{médian} sur le nom et en
	\textbf{mineur} sur le prénom : 

	\begin{center}
	\small\sffamily
	\begin{tabular}{cllrc}
		matricule 	& nom 		& prénom 	& dateNaissance & option \\
		\hline 
		30597 		& Dupont 	& Charles 	& 9/07/94 		& G\\
		30125 		& Dupont	& Fabrice 	& 13/06/94 		& G\\
		30351 		& Simon 	& André 	& 18/11/94 		& G\\
		31886 		& Durant  	& Sam 		& 30/05/94 		& I\\
		29845     	& Durant 	& Kevin 	& 20/01/94 		& R\\
		31857 		& Guilmant  & Léon 		& 17/03/96 		& R\\
		\hline 
	\end{tabular}
	\end{center}

	Remarque : un classement n’est pas forcément un classement alphabétique.
        Par exemple, dans le cas du classement sur l'option, toute autre
        permutation des lettres G, I, R serait un tri possible.

\subsection*{Résumé}
	Les exemples ci-dessus constituent des exemples de \textbf{classements complexes}. 
	On dira que des données sont classées sur la \textbf{clé composée} 
	champ $1$ – champ $2$ – \dots{} – champ $i$ – \dots{} – champ $n$ 
	(où \og{}champ $i$\fg{} est un attribut des données) 
	si le classement se fait prioritairement depuis le champ $1$ jusqu’au champ $n$. 
	Autrement dit, si deux données ont tous leurs champs $1$, $2$,\dots, $i$ égaux ($i<n$), 
	le classement se fait en départageant sur le champ $i+1$. 
	L’indice du champ correspond au \textbf{niveau} du classement complexe.

%=============================
\section{La notion de rupture}
%==============================

	Les algorithmes que nous allons voir 
	peuvent s'appliquer à n'importe quel \textbf{ensemble logique} d'éléments
	qui peut faire l'objet d'un traitement séquentiel
	(les listes, les tableaux\dots)%
	\footnote{%
		Et également les fichiers moyennant une petite adaptation
		liée au fait qu'on ne connait pas, dans ce cas, 
		la taille de l'ensemble lorsqu'on commence à le traiter.
	}. 
	Les éléments peuvent être de n'importe quel \textbf{type complexe}.
	Nos exemples seront souvent pris sur des listes de objets. 
		
	Nous parlons de \textbf{rupture} lorsque, dans ce traitement itératif, 
	on constate que l’information courante que l’on souhaite traiter
	n’appartient plus à l’ensemble (ou au sous-ensemble) 
	des informations déjà traitées précédemment.
	
	Lorsque les données sont triées selon une clé complexe, il est naturel
        de parler de \textit{rupture sur un champ} de ces données, ou de rupture
        de niveau donné (voir section suivante).
	
	Par exemple, dans le dernier classement des étudiants ci-dessus, il y a
	rupture sur l’option au niveau de Durant Sam et de Durant Kevin. En
	effet, ces deux étudiants délimitent les sous-ensembles d’étudiants
	partageant une même option.
		
	Dans le 2\ieme{} classement, nous pouvons parler de
	rupture sur les noms : l’étudiant Durant Kevin met fin au sous-ensemble
	des Dupont, et l’étudiant Guilmant met fin à celui des Durant.
		
	Dans le 1\ier{} classement, qui est un classement simple
	sur le numéro de matricule, on peut considérer qu’il n’y a qu’un
	ensemble de données d’un seul tenant sans ruptures (ou avec rupture de niveau 0, voir section suivante), ou alors qu’il y a
	rupture à chaque étudiant, puisque chaque étudiant forme un
	sous-ensemble isolé par son numéro de matricule, vu qu’ils sont
	obligatoirement distincts (mais dans ce cas nous n'utilisons pas 
        l'algorithme de rupture : c'est une simple itération sur la liste).
	
%===========================================================
\section{Traitement des ruptures dans une séquence ordonnée}
%===========================================================

\subsection*{Rupture de niveau 0}

	Quel que soit l’ordre de tri des données de l'ensemble parcouru séquentiellement, 
	il est toujours possible de détecter la fin des données grâce à sa taille%
	\footnote{%
		Ou via une marque spéciale de \emph{fin de fichier}
		dans les cas des fichiers séquentiels.
	}.
	Cette \og{}fin\fg{} constitue donc la rupture principale, 
	celle signalant la fin du parcours itératif.
	
	Sans le savoir, nous avons donc déjà traité la rupture générale d’un
	ensemble de données (c’est la rupture de «~niveau 0~»,
	car elle n’est pas liée à un champ des données, 
	et est naturellement prioritaire sur ces champs). 
	Pour illustrer cela, reprenons l’exemple de la liste d’étudiants. 
	Le parcours de base de cet ensemble est le suivant :

	\begin{algo}
		\Algo{RuptureNiveau0}{\Par{etudiants}{\List{Etudiant}}}{}{
			\ForAll{étudiant : étudiants \Comment{pour tout étudiant de la liste des étudiants}}{
				\Comment{traitement de l'étudiant}\;
			}
		}
	\end{algo}

	Un tel algorithme se réaliserait naturellement avec un boucle \lda{for}.
	Nous allons pourtant la réaliser avec un \lda{while} car cela permet
	de généraliser l'algorithme à des ruptures de plusieurs niveaux.
	Ce qui donne :

	\begin{algo}
		\Algo{RuptureNiveau0}{\Par{etudiants}{\List{Etudiant}}}{}{
			\Decl{i}{integer}\;
			i \Gets 0\;
			\While{i < etudiants.size()}{
				\Comment{traitement de etudiants.get(i)}\;
				i++\;
			}
		}
	\end{algo}

	Si nous voulons faire des statistiques globales sur l’ensemble des
	étudiants (par ex. simplement les compter), le traitement de
	l’information consiste à incrémenter un compteur, et l’algorithme
	ci-dessus peut fonctionner quel que soit l’ordre de classement choisi.

\subsection*{Rupture de niveau 1}

	Passons à présent au «~niveau 1~» ; c’est-à-dire un traitement de
	rupture correspondant à un classement sur un champ. 
	Imaginons que nous voulions savoir quel est le nombre d’étudiants dans chaque option. 
	Une solution, sans algorithme de rupture, consisterait à avoir 3 compteurs, un par option.
	On peut imaginer une façon plus judicieuse de faire à partir du dernier classement, celui
	qui contient précisément les étudiants déjà groupés par option : 
	à chaque fois qu’il y a rupture sur l’option, 
	on peut alors connaitre le total d’étudiants dans l’option qui vient d’être parcourue. 
	Ceci ne nécessite qu’un seul compteur remis à 0 à chaque fois qu’une nouvelle
	option est rencontrée, c’est-à-dire à chaque rupture. 
	De plus l’algorithme fonctionnera quel que soit le nombre d’options. 
	
	En gros, ça donne :

	\begin{algo}
		\label{algo:rupt1a}
		\Algo{RuptureNiveau1}{\Par{etudiants}{List of Etudiant}}{}{
			\Comment{on suppose les données classées en majeur sur l’option}\;
			\ForAll{étudiant : étudiants}{
				cptEtudiantsOption \Gets 0\;
				\ForAll{étudiants de la même option}{
					cptEtudiantsOption++\;
				}
				\Write cptEtudiantsOption et l'option\;
			}
		}
	\end{algo}

	\bigskip
	\begin{infotbox}{Retenons}
		Lorsqu'on calcule une variable liée à un niveau de rupture
		-- dans notre exemple, le nombre d'étudiants par option est lié 
		à l'option, donc au niveau 1 -- la variable :
		\begin{itemize}
			\item est initialisée juste avant d'entrer dans la boucle du niveau;
			\item est mise à jour dans la boucle;
			\item a sa valeur finale quand la boucle du niveau est finie.
		\end{itemize}
	\end{infotbox}

	\newpage
	Soyons plus précis dans notre algorithme :

	\begin{algo}
		\label{algo:rupt1}
		\Algo{RuptureNiveau1}{\Par{etudiants}{List of Etudiant}}{}{
			\Comment{on suppose les données classées en majeur sur l’option}\;
			\Decl{saveOption}{string}\;
			\Decl{cptEtudiantsOption}{integer}\;
			\Decl{i}{integer}\;
			\;
			\nivo{i \Gets 0} \RComment{En \nivo{brun} ce qui est lié au niveau 0}
			\While{{\color{colnivo}i < etudiants.size()}}{
				\nivi{saveOption \Gets etudiants.get(i).getOption()}
				\RComment{En \nivi{orange} ce qui est lié au niveau 1}
				\nivc{cptEtudiantsOption \Gets 0}
				\RComment{En \nivc{bleu} ce qui est lié à la question posée}
				\While{ \nivo{i < etudiants.size()} 
					ET \nivi{etudiants.get(i).getOption() = saveOption}}{
					\nivc{cptEtudiantsOption++}\;
					\nivo{i++}\;
				}
				\Write \nivc{cptEtudiantsOption, «~étudiant dans l’option~», saveOption}\;
			}
		}
	\end{algo}

	\medskip
	Questions de réflexion :
	\begin{itemize}
		\item 
			pourquoi la condition \textsf{i < etudiants.size()}
			apparait-elle une 2\ieme{} fois dans la boucle intérieure ?
		\item 
			pourquoi est-ce que \textsf{i} et \textsf{cptEtudiantsOption} 
			ne sont pas initialisés au même endroit ?
		\item 
			pourquoi l'incrémentation de \textsf{i} se fait-elle dans la boucle centrale 
			et pas ailleurs ?
		\item 
			pourquoi utilise-t-on 
			\textsf{saveOption} plutôt que \textsf{etudiants.get(i).getOption()}
			dans l’instruction d’affichage ?
		\item 
			l’ordre des conditions apparaissant dans le 2\ieme{} \og{}tant que\fg{} 
			est-il important ?
	\end{itemize}

	Voici le même algorithme écrit en \bsc{Java} :
	\listing*[linerange=13-27]{java}{java/src/main/java/dev2/algo/rupture/ExempleRupture1.java}

\subsection*{Rupture de niveau 2}

	L’algorithme ci-dessus se généralise facilement si on ajoute davantage de niveaux de rupture. 
	Pour illustrer le «~niveau 2~», prenons encore l’exemple suivant : 
	on veut connaitre pour chaque option le nombre d’étudiants nés dans les différentes années de naissance. 
	L’algorithme correspondant s’écrit facilement et fonctionne lorsque les données sont, cette fois-ci,
	classées en majeur sur l'option et en mineur sur la date de naissance
	(ou encore classement double sur la clé composée option – dateNaissance).

	En voici une première version, schématique :
	\begin{algo}
		\Algo{RuptureNiveau2}{\Par{etudiants}{List of Etudiant}}{}{
			\Comment{on suppose les données classées en majeur sur l’option}\;
			\Comment{et en mineur sur la date de naissance (ordre chronologique)}\;
	
			\ForAll{étudiant : étudiants}{
				\ForAll{étudiants de la même option}{
					cptEtudiantsAnnéeOption \Gets 0\;
					\ForAll{étudiants de la même année dans l'option}{
						cptEtudiantsAnnéeOption++\;
					}
					\Write cptEtudiantsAnnéeOption, l'année et l'option\;
				}
			}
		}
	\end{algo}
	
	Remarquez bien où la variable \lda{cptEtudiantsAnnéeOption}
	est : initialisée, mise à jour, affichée.
	Voici une version plus détaillée :

	\begin{algo}
		\Algo{RuptureNiveau2}{\Par{etudiants}{List of Etudiant}}{}{
		\label{algo:rupt2}
			\Comment{on suppose les données classées en majeur sur l’option}\;
			\Comment{et en mineur sur la date de naissance (ordre chronologique)}\;
			\Decl{saveOption}{string}\;
			\Decl{saveAnnéeNaissance}{integer}\;
			\Decl{cptEtudiantsAnnéeOption}{integer}\;
			\Decl{i}{integer}\;
	
			\nivo{i \Gets 0}\;
			\While{\nivo{i < etudiants.size()}}{
				\nivi{saveOption \Gets etudiants.get(i).getOption()}\;
				\While{\nivo{i < etudiants.size()} ET \nivi{etudiants.get(i).getOption() = saveOption}}{
					\nivii{saveAnnéeNaissance \Gets etudiants.get(i).getNaissance().getAnnée()}\;
					\nivc{cptEtudiantsAnnéeOption \Gets 0}\;
					\While{ \nivo{i < etudiants.size()}
							ET \nivi{etudiants.get(i).getOption() = saveOption}
							ET \nivii{etudiants.get(i).getNaissance().getAnnée() = saveAnnéeNaissance}
							}{
						\nivc{cptEtudiantsAnnéeOption++}\;
						\nivo{i++}\;
					}
					\Write \nivc{cptEtudiantsAnnéeOption, "~étudiant dans l’option~", saveOption, 
					"~sont nés en~", saveAnneeNaissance}\;
				}
			}
		}
	\end{algo}

	Ces exemples montrent que l’algorithme de rupture 
	et le tri des listes sont étroitement liés. 
	La structure de l’algorithme épouse le schéma de la clé composée du classement des données,
	et à un classement déterminé correspondra un algorithme bien précis.

	\subsubsection*{Le nombre d'étudiant par option ET par année de l'option.}
	
	Comment faire si on veux 
	\textbf{à la fois}
	le nombre d'étudiants par option et le nombre d'étudiants par année (de l'option) ?
	Voici une solution schématique.
	Remarquez bien à quels endroits se font les initialisations, les mises à jour
	et les affichages.

	\newpage
	\begin{algo}
		\Algo{RuptureNiveau2bis}{\Par{etudiants}{List of Etudiant}}{}{
			\ForAll{étudiant : étudiants}{
				cptEtudiantsOption \Gets 0\;
				\ForAll{étudiants de la même option}{
					cptEtudiantsAnnéeOption \Gets 0\;
					\ForAll{étudiants de la même année dans l'option}{
						cptEtudiantsAnnéeOption++\;
						cptEtudiantsOption++\;
					}
					\Write cptEtudiantsAnnéeOption, l'année et l'option\;
				}
				\Write cptEtudiantsOption et l'option\;
			}
		}
	\end{algo}

	Vous pouvez remarquer que la mise à jour se fait dans la boucle la plus interne
	pour les deux variables !
	Dans cet exemple précis de comptage, on pourrait mettre-à-jour le nombre 
	d'étudiants par option de façon plus efficace.

	\begin{algo}
		\Algo{RuptureNiveau2bis}{\Par{etudiants}{List of Etudiant}}{}{
			\ForAll{étudiant : étudiants}{
				cptEtudiantsOption \Gets 0\;
				\ForAll{étudiants de la même option}{
					cptEtudiantsAnnéeOption \Gets 0\;
					\ForAll{étudiants de la même année dans l'option}{
						cptEtudiantsAnnéeOption++
						\RComment{Plus de mise à jour de cptEtudiantsOption ici !}
					}
					\Write cptEtudiantsAnnéeOption, l'année et l'option\;
					cptEtudiantsOption += cptEtudiantsAnnéeOption
					\RComment{La mise à jour se fait ici}
				}
				\Write cptEtudiantsOption et l'option\;
			}
		}
	\end{algo}

% %====================================================
% \section{Traitements de clôture et d’initialisation}
% %====================================================

% 	Chaque rupture du traitement itératif des éléments d’un ensemble
% 	entraine un \textbf{traitement de clôture} sur cet ensemble. Comme une
% 	rupture à un niveau implique des ruptures en cascade sur tous les
% 	niveaux d’ordres plus grands, un traitement de clôture d’un ensemble ne
% 	pourra se faire que lorsque le dernier sous-ensemble de cet ensemble
% 	sera clôturé.
	
% 	De la même manière, l’arrivée d’un élément appartenant à un nouvel
% 	ensemble nécessite un \textbf{traitement d’initialisation} de ce nouvel
% 	ensemble.
	
% 	En fait, il ne s’agit que de généraliser ce qui se fait au niveau 0 
% 	(travaux d’initialisation consistant par exemple à mettre des totalisateurs 
% 	ou compteurs à zéro et travaux de clôture consistant par exemple 
% 	à imprimer des résultats totaux particuliers) 
% 	à tous les ensembles et sous-ensembles !

%==================
\section{Exercices}
%===================


\begin{Exercice}{La chasse au gaspi [rupture de niveau 1]}
	À l’ÉSI, les quantités de feuilles imprimées et photocopiées 
	par les professeurs et les étudiants sont enregistrées à des fins de traitement.
	Le service technique désirant facturer les «~exagérations~», 
	vous fournit une liste de toutes les impressions effectuées depuis le début de l'année.
	Cette liste est composée d'objets de la classe \lda{Job} suivante 
	et est ordonnée alphabétiquement \textbf{en majeur} sur le champ \lda{login}  :

	\begin{algo}
		\Class{Job}{
			\Private{
				\Decl{login}{string}\;
				\Decl{date}{date}\;
				\Decl{nombre}{integer}\;
			}
			\Public{
				\Comment{Le constructeur et les getteurs}
			}
		}
	\end{algo}

	Écrire un algorithme permettant d'afficher une ligne 
	(avec login et nombre) par
	utilisateur dont le nombre total de feuilles imprimées dépasse une
	valeur limite entrée en paramètre. 
\end{Exercice}
\begin{Solution}
  \begin{algo}
    \Algo{stopGaspi}{\Par{jobs}{Liste de Job}, \Par{limitePrn}{entier}}{}{
      \Comment{jobs est triée en majeur sur le login}\;
      \Decl{i}{entier}\;
      \Decl{cptPrn}{entier}\;
      \Decl{saveLogin}{chaîne}\;
      \While{i < jobs.size() }{
        \Assign{cptPrn}{0}\;
        \Assign{saveLogin}{jobs.get(i).login}\;
        \While{i < jobs.size() ET jobs.get(i).login = saveLogin }{
          \Assign{cptPrn}{cptPrn + jobs.get(i).nombre}\;
          \Assign{i}{i + 1}\;
        }
        \If{cptPrn > limitePrn }{
          \Write  "Alerte : " + saveLogin + " " + cptPrn\;
        }
      }
    }
  \end{algo}
\end{Solution}

\newpage

% \begin{Exercice}{Compter le nombre d'étudiants par option}
% 	Reprenons l'exemple donné pour la rupture de niveau 2 (\lda{RuptureNiveau2}, page \pageref{algo:rupt2}).
% 	Que faut-il ajouter à l'algorithme pour qu'il affiche également 
% 	le nombre total d'étudiants par option ?
% \end{Exercice}

% \begin{Solution}
%   \begin{algo}
%     \Algo{RuptureNiveau2}{\Par{etudiants}{liste d’ Etudiant}}{}{
%       \Comment{on suppose les données classées en majeur sur l’option}\;
%       \Comment{et en mineur sur la date de naissance (ordre chronologique)}\;
%       \Decl{etd}{Etudiant}\;
%       \Decl{saveOption}{chaine}\;
%       \Decl{saveAnnéeNaissance}{entier}\;
%       \Decl{cpt, cptOpt}{entier} \Comment{ICI}\;
%       \Decl{i}{entier}\;
%       \Assign{i}{0}\;
%       \While{i < etudiants.size() }{
%         \Assign{saveOption}{etd.option}\;
%         \Assign{cptOpt}{0} \Comment{ICI}\;
%         \While{i < etudiants.size() ET etudiants.get(i).option = saveOption }{
%           \Assign{saveAnnéeNaissance}{etudiants.get(i).dateNaissance.année}\;
%           \Assign{cpt}{0}\;
%           \While{i < etudiants.size()
%              ET etudiants.get(i).option = saveOption
%              ET etudiants.get(i).dateNaissance.année = saveAnnéeNaissance}{
%             \Assign{cpt}{cpt + 1}\;
%             \Assign{cptOpt}{cptOpt + 1} \Comment{ICI}\;
%             \Assign{i}{i + 1}\;
%           }
%           \Write  cpt, " étudiant(s) dans l’option ", saveOption, " est(sont) né(s) en ", saveAnneeNaissance\;
%         }
%         \Write  cptOpt, " étudiant(s) dans l'option ", saveOption \Comment{ICI}\;
%       }
%     }
% \end{algo}
% \end{Solution}

\begin{Exercice}{Compter les étudiants [rupture de niveau 2]}
	Supposons que la classe \lda{Etudiant} contienne également
	un attribut indiquant dans quel bloc se trouve l'étudiant (1, 2 ou 3).
	On voudrait un algorithme qui reçoit une liste d'étudiants et calcule
	le nombre d'étudiants dans chaque section et, par section, dans chaque bloc.
	
	L'affichage ressemblera à :
	{\footnotesize
	\begin{verbatim}
    Gestion
        bloc 1 : 130 étudiants
        bloc 2 : 42 étudiants
        bloc 3 : 16 étudiants
        TOTAL  : 188 étudiants
    Industriel
        bloc 1 : 32 étudiants
        bloc 2 : 14 étudiants
        bloc 3 : 8 étudiants
        TOTAL  : 54 étudiants
    Réseau
        bloc 1 : 82 étudiants
        bloc 2 : 31 étudiants
        bloc 3 : 13 étudiants
        TOTAL  : 126 étudiants
	\end{verbatim}
	}
	\begin{enumerate}[label=\alph*)]
		\item 
		Quel doit-être le tri pour pouvoir résoudre cet exercice
		avec un algorithme de rupture ?
		\item 
		Écrire cet algorithme.
	\end{enumerate}
\end{Exercice}

\begin{Solution}
  \begin{algo}
\Algo{afficherComptageEtudiants}{\Par{etudiants}{liste d' Etudiants}}{}{
  \Decl{saveOption, saveBloc}{chaine}\;
  \Decl{cptEtudiantOption, cptEtudiantBloc, i}{entier}\;
  \Assign{i}{0}\;
  \While{i < etudiants.size() }{
    \Assign{saveOption}{etudiants.get(i).option}\;
    \Comment{initialisation pré-rupture 1}\;
    \Assign{cptEtudiantOption}{0}\;
    \Write  saveOption\;
    \While{i < etudiants.size() ET (etudiants.get(i)).option = saveOption }{
      \Assign{saveBloc}{etudiants.get(i).bloc}\;
      \Comment{initialisation pré-rupture 2}\;
      \Assign{cptEtudiantBloc}{0}\;
      \While{i < etudiants.size() ET etudiants.get(i).option = saveOption ET etudiants.get(i).bloc = saveBloc }{
        \Comment{traitement des éléments de la liste}\;
        \Assign{cptEtudiantBloc}{cptEtudiantBloc + 1}\;
        \Assign{i}{i + 1}\;
      }
      \Comment{traitement post-rupture 2}\;
      \Assign{cptEtudiantOption}{cptEtudiantOption + cptEtudiantBloc}\;
      \Write  "    bloc " + saveBloc + " : " + cptEtudiantBloc + " étudiants"\;
    }
    \Comment{traitement post-rupture 1}\;
    \Write  "    TOTAL  : " + saveOption + " étudiants"\;
  }
}
\end{algo}
\end{Solution}
	
\begin{Exercice}{Les fanas d'info  [rupture de niveau 2]}
	Une grande société d’informatique a organisé durant les douze derniers
	mois une multitude de concours ouverts aux membres de clubs d’informatique. 
	Elle souhaiterait récompenser le club qui aura été le plus «~méritant~» 
	durant cette période au point de vue de la participation des membres mineurs. 
	Chaque résultat individuel des participants (y compris des majeurs) est repris dans une liste
	dont les éléments sont de type \lda{Participant}.

	\begin{algo}
	\Class{Participant}{
		\Private{
			\Decl{nom}{string} 		\RComment{nom et prénom du participant}
			\Decl{âge}{integer} 		\RComment{âge du participant au moment du concours}
			\Decl{référence}{string}\RComment{référence du club auquel appartient ce participant}
			\Decl{numéro}{integer}	\RComment{numéro du concours auquel il a participé}
			\Decl{résultat}{integer}	\RComment{résultat obtenu lors de ce concours (sur 100)}
		}
		\Public{
			\Comment{Le constructeur et les getteurs}
		}
	}
	\end{algo}

	Sachant que la liste est ordonnée \textbf{en majeur sur le champ \textsf{référence}
	et en mineur sur le champ \lda{nom}}, 
	on demande d’écrire l’algorithme qui affiche les informations suivantes :

	pour chaque club :
	\begin{itemize}
		\item 
			sa référence
		\item 
			pour chaque membre mineur de ce club :
        \begin{itemize}
		    \item 
			   son nom et prénom
		    \item 
			   la cote moyenne sur 100 des concours auquel ce membre a participé
        \end{itemize}
		\item 
			le nombre total de participations des membres mineurs
	\end{itemize}
	
	\textbf{N.B.~:} un membre mineur qui s’est inscrit à un concours = une
	participation. Un club qui n’aura eu aucun membre mineur participant
	figurera quand même dans le résultat avec la mention 
	\og{}Pas de participation de membre mineur\fg{}. 
	Par contre, un club dont aucun membre n’a participé au moindre concours ne sera pas affiché.

	À la fin, on affichera la référence du meilleur club, à savoir celui qui
	a eu la plus haute cote moyenne de membres mineurs 
	(simplifions on ne gérant pas les possibles ex-\ae{}quo).

\end{Exercice}
\begin{Solution}
\begin{algo}
  \Algo{club}{\Par{membres}{Liste de Participant}}{}{
    \Decl{n}{entier}\;
    \Decl{mineur}{booléen}\;
    \Decl{saveNom, saveRef}{chaîne}\;
    \Decl{accumRésultat, nbResultats}{entier}\;
    \Decl{nbMineursClub}{entier}\;
    \Assign{n}{membres.size()}\;
    \Assign{i}{0}\;
    \While{i < n }{
      \Assign{saveRef}{membres.get(i).reference}\;
      \Assign{nbMineursClub}{0}\;
      \Write  "Participations de mineurs du club " + saveRef\;
      \While{i < n ET saveRef = membres.get(i).reference }{
        \Assign{saveNom}{membres.get(i).nom}\;
        \Assign{accumRésultat}{0}\;
        \Assign{nbResultats}{0}\;
        \Assign{mineur}{membres.get(i).age < 18}\;
        \While{i < n ET saveRef = membres.get(i).reference ET saveNom = membres.get(i).nom }{
          \Assign{accumRésultat}{accumRésultat + membres.get(i).resultat}\;
          \Assign{nbResultats}{nbResultats + 1}\;
          \Assign{i}{i + 1}\;
        }
        \If{mineur }{
          \Assign{nbMineursClub}{nbMineursClub + 1}\;
          \Write  saveNom + accumRésultat/nbResultats\;
        }
      }
      \eIf{nbMineursClub > 0 }{
        \Write  "Nombre total de membres mineurs de ce club : " + nbMineursClub\;
      }{
        \Write  "Pas de participations de mineurs pour ce club"\;
      }
    }
  }
\end{algo}
\end{Solution}

\newpage
\begin{Exercice}{Éliminer les doublons d'une liste.}
	Soit une liste ordonnée d'entiers avec des possibles redondances. 
	Écrire un algorithme qui enlève les redondances de la liste. 
	On vous demande de créer une nouvelle liste (la liste de départ reste inchangée).
	
	Exemple : si la liste est $(1, 3, 3, 7, 8, 8, 8)$ 
	le résultat sera $(1, 3, 7, 8)$.
\end{Exercice}

\begin{Exercice}{Une suite logique}
	Voici une petite suite logique :
	
	\begin{minipage}{5cm}
		\small
		\begin{verbatim}
	1
	1 1
	2 1
	1 2 1 1
	1 1 1 2 2 1
	3 1 2 2 1 1
	1 3 1 1 2 2 2 1
	1 1 1 3 2 1 3 2 1 1
	3 1 1 3 1 2 1 1 1 3 1 2 2 1
	...
		\end{verbatim}
	\end{minipage}
	\begin{minipage}{9cm}
		\begin{enumerate}[label=\alph*)]
		\item
			Comprendre la logique derrière cette suite 
			et écrire la ligne suivante.
		\item
			Écrire un algorithme qui reçoit une ligne 
			(sous forme d'une liste d'entiers) 
			et retourne la ligne suivante 
			(sous forme d'une autre liste d'entiers).
			Votre première tâche sera probablement de comprendre 
			ce que vient faire cet exercice dans le chapitre des ruptures puisque la liste n'est pas triée.
		\item
			Écrire l'algorithme qui reçoit $N$ (un entier) 
			et affiche les $N$ premières lignes de cette suite logique.	
		\end{enumerate}
	\end{minipage}
\end{Exercice}

\begin{Exercice}{Alternative à la rupture}
	Reprenons l'exemple donné pour la rupture de niveau 1 (\lda{RuptureNiveau1}, page \pageref{algo:rupt1}).
	Supposons que la liste ne soit \textbf{pas} triée sur l'option.
	Écrivez l'algorithme qui calcule le nombre d'étudiants par option en un seul parcours de la liste
	(vous devrez utiliser trois compteurs distincts).
\end{Exercice}

\begin{Exercice}{Nombre d'étudiants par année et par option}
	Reprenons l'exemple donné pour la rupture de niveau 2 (\lda{RuptureNiveau2}, 
	page \pageref{algo:rupt2}). 
	Et si, à présent,
	on veut \textbf{à la fois} le nombre d'étudiant par option 
	\textbf{et} le nombre d'étudiants par année 
	(\textbf{toutes les années confondues}) ?
	Comment faire ?
\end{Exercice}
